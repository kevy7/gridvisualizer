{"version":3,"sources":["userActions/userActions.js","actions/index.js","actions/types.js","Components/Node/Node.js","Algorithms/BreadthFirstSearch.js","Algorithms/Algofunctions/Algofunctions.js","Algorithms/DebthFirstSearch.js","dataStructures/priorityQueue.js","Algorithms/Dijkstra.js","Algorithms/GreedyBestFirstSearch.js","Algorithms/ATreeSearch.js","MazeAlgorithms/setOuterWalls.js","MazeAlgorithms/recursiveDivision.js","userAlgo/userAlgo.js","functions/ifContainsObject.js","Components/Grid/Grid.js","Components/NavBar/NavBar.js","App.js","reducers/selectActionReducer.js","reducers/selectGridReducer.js","reducers/selectAlgoReducer.js","reducers/index.js","store.js","index.js","Components/Grid/Grid.module.css"],"names":["selectStartNode","selectEndNode","selectTraffic","selectWall","selectAction","userAction","dispatch","type","payload","Node","state","iconName","isHovered","clickButton","console","log","props","selectGridData","selectedGrid","row","column","selectedGrids","startingSelected","selectGrid","updateState","endingSelected","distance","prevNode","mouseDownEvent","e","setState","document","getElementById","focus","isWall","isStart","isEnd","isWeight","className","mouseOutEvent","pressDownKey","key","toLowerCase","myStyle","background","this","isPath","id","onClick","onMouseEnter","onMouseLeave","onKeyDown","tabIndex","style","Component","connect","BFS","grid","startRow","startColumn","endRow","endColumn","current","maxRow","length","maxColumn","startingNode","queue","visited","isVisited","push","shift","childrens","getChildren","a","shortestPath","getShortestPath","node","children","endingNode","undefined","getChildrens","DFS","startCol","endCol","maxCol","stack","currentNode","pop","priorityQueue","addQueue","includes","currentIdx","parentIdx","Math","floor","parent","addQueueFValue","fValue","deQueue","firstPriority","lastPriority","sinkDown","leftidx","rightidx","left","right","swap","childNode","deQueueFValue","sinkDownFValue","Dijkstra","prevRow","prevColumn","manhattanDistance","abs","GreedyBestFirstSearch","childRow","childCol","ATreeSearch","heuristic","currentDistance","setOuterWalls","width","height","mazeWalls","b","recursiveDivision","minWidth","maxWidth","minHeight","maxHeight","orientation","fieldWidth","fieldHeight","randomColumnIdx","randomRowIdx","selectedColumn","selectedOpeningRow","selectableColumns","openingRows","random","trueMaxHeight","concat","randRowIdx","randColumnIdx","selectedRow","selectedOpeningColumn","selectableRows","openingColumn","trueMinWidth","trueMaxWidth","BreadthFS","DebthFS","GreedyBFS","ifContainsObject","arrayObjects","objectVal","ifContains","Grid","action","traffic","walls","componentWillMount","createInitialGrid","addTraffic","selectedNode","newWalls","filter","wall","addWall","newTraffic","trafficVal","resetGrid","forEach","resetSelectedGrids","animatePath","algoResult","nodes","startingGrid","endingGrid","index","selectedAlgo","setTimeout","reverse","alert","testFunction","gridCopy","testArray","test","testArray2","round","window","innerWidth","nodeRows","createNode","Infinity","algoButton","onresize","map","rowidx","Styles","columnidx","NavBar","selectUserAction","startAction","innerHTML","selectStartAction","selectEndAction","selectTrafficAction","selectWallAction","selectBFSAlgo","selectAlgorithm","selectDFSAlgo","selectDijkstraAlgo","selectGreedyBFS","selectATreeAlgo","selectTest","href","src","alt","data-target","ref","input","endAction","data-social-network","data-social-action","data-social-target","target","algorithm","App","initialState","selectActionReducer","selectGridReducer","selectAlgoReducer","combineReducers","middleware","thunk","store","createStore","reducers","compose","applyMiddleware","__REDUX_DEVTOOLS_EXTENSION__","ReactDOM","render","module","exports"],"mappings":"kRAAaA,EAAkB,uBAClBC,EAAgB,uBAChBC,EAAgB,sBAChBC,EAAa,sBCcbC,EAAe,SAACC,GAAD,OAAgB,SAAAC,GAErCD,GACDC,EAAS,CACLC,KCrBmB,gBDsBnBC,QAASH,MEdbI,G,kNAEFC,MAAQ,CACJC,SAAU,GACVC,WAAW,G,EAIfC,YAAc,WAGVC,QAAQC,IAAI,EAAKC,OAEjB,IAAIC,EAAiB,CACjBZ,WAAY,EAAKW,MAAMX,WACvBa,aAAc,CACVC,IAAK,EAAKH,MAAMG,IAChBC,OAAQ,EAAKJ,MAAMI,SAIxB,EAAKJ,MAAMX,aAAeL,GACwB,IAA9C,EAAKgB,MAAMK,cAAcC,mBACxB,EAAKN,MAAMO,WAAWN,GACtB,EAAKD,MAAMQ,YAAY,EAAKR,MAAMG,IAAK,EAAKH,MAAMI,OAAQ,EAAKJ,MAAMX,YACrE,EAAKW,MAAMZ,aAAaH,IAGxB,EAAKe,MAAMX,aAAeJ,GACiB,IAA5C,EAAKe,MAAMK,cAAcI,iBACxB,EAAKT,MAAMO,WAAWN,GACtB,EAAKD,MAAMQ,YAAY,EAAKR,MAAMG,IAAK,EAAKH,MAAMI,OAAQ,EAAKJ,MAAMX,YACrE,EAAKW,MAAMZ,aAAaJ,IHpCd,YG0CV,EAAKgB,MAAMX,aAEfS,QAAQC,IAAI,EAAKC,MAAMU,UACvBZ,QAAQC,IAAI,cAAe,EAAKC,MAAMW,Y,EAQ9CC,eAAiB,SAACC,GAEd,EAAKC,SAAS,CAAClB,WAAW,IAE1BmB,SAASC,eAAT,qBAAsC,EAAKhB,MAAMG,IAAjD,YAAwD,EAAKH,MAAMI,SAAUa,SAGpD,IAAtB,EAAKjB,MAAMkB,SAA2C,IAAvB,EAAKlB,MAAMmB,UAA0C,IAArB,EAAKnB,MAAMoB,QAA2C,IAAxB,EAAKpB,MAAMqB,WACvGN,SAASC,eAAT,eAAgC,EAAKhB,MAAMG,IAA3C,YAAkD,EAAKH,MAAMI,SAAUkB,UAAY,EAAKtB,MAAMX,a,EAItGkC,cAAgB,SAACV,GACb,EAAKC,SAAS,CAAClB,WAAW,KAGD,IAAtB,EAAKI,MAAMkB,SAA2C,IAAvB,EAAKlB,MAAMmB,UAA0C,IAArB,EAAKnB,MAAMoB,QAA2C,IAAxB,EAAKpB,MAAMqB,WACvGN,SAASC,eAAT,eAAgC,EAAKhB,MAAMG,IAA3C,YAAkD,EAAKH,MAAMI,SAAUkB,UAAY,K,EAK3FE,aAAe,SAACX,GAGT,EAAKnB,MAAME,WAAqC,MAAxBiB,EAAEY,IAAIC,cAC1B,EAAK1B,MAAMX,aAAeH,GACzB,EAAKc,MAAMQ,YAAY,EAAKR,MAAMG,IAAK,EAAKH,MAAMI,OAAQ,EAAKJ,MAAMX,YAIrE,EAAKK,MAAME,WAAqC,MAAxBiB,EAAEY,IAAIC,eAC/B,EAAK1B,MAAMX,aAAeF,GACzB,EAAKa,MAAMQ,YAAY,EAAKR,MAAMG,IAAK,EAAKH,MAAMI,OAAQ,EAAKJ,MAAMX,a,wEAQ7E,IAAIsC,EAAU,CACVC,WAAY,IAGZjC,EAAW,GAoBf,OAlByB,IAAtBkC,KAAK7B,MAAM8B,SACVH,EAAQC,WAAa,wBAEC,IAAvBC,KAAK7B,MAAMmB,QACVxB,EAAWX,GAEc,IAArB6C,KAAK7B,MAAMoB,MACfzB,EAAWV,GAEiB,IAAxB4C,KAAK7B,MAAMqB,SACf1B,EAAWT,GAEe,IAAtB2C,KAAK7B,MAAMkB,SACfvB,EAAW,aAMX,yBACIoC,GAAE,qBAAgBF,KAAK7B,MAAMG,IAA3B,YAAkC0B,KAAK7B,MAAMI,QAC/CkB,UAAU,OACVU,QAASH,KAAKhC,YACdoC,aAAcJ,KAAKjB,eACnBsB,aAAcL,KAAKN,cACnBY,UAAWN,KAAKL,aAChBY,SAAS,IACTC,MAAOV,GAEP,yBACII,GAAE,eAAUF,KAAK7B,MAAMG,IAArB,YAA4B0B,KAAK7B,MAAMI,QACzCkB,UAAU,QAEV,uBACIS,GAAE,eAAUF,KAAK7B,MAAMG,IAArB,YAA4B0B,KAAK7B,MAAMI,QACzCkB,UAAW3B,U,GAnIhB2C,cAmKJC,eAPS,SAAC7C,GACrB,MAAO,CACHL,WAAYK,EAAML,WAAWA,WAC7BgB,cAAeX,EAAMW,iBAIW,CACpCE,WFhJsB,SAACN,GAAD,OAAoB,SAAAX,GAWvCW,EAAeZ,aAAeL,EAC7BM,EAAS,CACLC,KCxCqB,oBDyCrBC,QAASS,EAAeC,eAGvBD,EAAeZ,aAAeJ,GACnCK,EAAS,CACLC,KC7CmB,kBD8CnBC,QAASS,EAAeC,iBE6HhCd,aAAcA,GAFHmD,CAGZ9C,G,YC1KI,SAAS+C,EAAIC,EAAMC,EAAUC,EAAaC,EAAQC,GAErD,IAIIC,EAHAC,EAASN,EAAKO,OACdC,EAAYR,EAAK,GAAGO,OACpBE,EAAeT,EAAKC,GAAUC,GAE9BQ,EAAQ,GACRC,EAAU,GAed,IATAF,EAAaG,WAAY,EACzBD,EAAQE,KAAK,CACTnD,IAAKuC,EACLtC,OAAQuC,IAIZQ,EAAMG,KAAKJ,GAELC,EAAMH,QAAO,CAEfF,EAAUK,EAAMI,QAMhB,IAJA,IAAIC,EAAYC,EAAYX,EAASC,EAAQE,GAIpCS,EAAI,EAAGA,EAAIF,EAAUR,OAAQU,IAAI,CACtC,IAAIvD,EAAMqD,EAAUE,GAAGvD,IACnBC,EAASoD,EAAUE,GAAGtD,OAE1B,IAAGqC,EAAKtC,GAAKC,GAAQiD,YAIlBZ,EAAKtC,GAAKC,GAAQc,OAArB,CAeA,GAXAuB,EAAKtC,GAAKC,GAAQiD,WAAY,EAC9BD,EAAQE,KAAK,CACTnD,IAAKA,EACLC,OAAQA,IAGZqC,EAAKtC,GAAKC,GAAQO,SAAW,CACzBR,IAAK2C,EAAQ3C,IACbC,OAAQ0C,EAAQ1C,QAGjBwC,IAAWY,EAAUE,GAAGvD,KAAO0C,IAAcW,EAAUE,GAAGtD,OAIzD,MAAO,CACHuD,aAHeC,EAAgBnB,EAAMA,EAAKtC,GAAKC,IAI/CgD,QAASA,GAIjBD,EAAMG,KAAKb,EAAKtC,GAAKC,OAQjC,IAAMqD,EAAc,SAACI,EAAMd,EAAQE,GAG/B,IAAI9C,EAAM0D,EAAK1D,IACXC,EAASyD,EAAKzD,OACd0D,EAAW,GAkCf,OA5BG1D,EAAO,GAAK,GACX0D,EAASR,KAAK,CACVnD,IAAKA,EACLC,OAAQA,EAAO,IAIpBA,EAAO,EAAI6C,GACVa,EAASR,KAAK,CACVnD,IAAKA,EACLC,OAAQA,EAAO,IAIpBD,EAAI,GAAK,GACR2D,EAASR,KAAK,CACVnD,IAAKA,EAAI,EACTC,OAAQA,IAIbD,EAAI,EAAG4C,GACNe,EAASR,KAAK,CACVnD,IAAKA,EAAI,EACTC,OAAQA,IAIT0D,GAILF,EAAkB,SAACnB,EAAMsB,GAC3B,IAAIjB,EAAUL,EAAKsB,EAAW5D,KAAK4D,EAAW3D,QAC1CuD,EAAe,GAOnB,IALAA,EAAaL,KAAK,CACdnD,IAAK4D,EAAW5D,IAChBC,OAAQ2D,EAAW3D,cAGI4D,IAArBlB,EAAQnC,UAEVmC,EAAUL,EAAKK,EAAQnC,SAASR,KAAK2C,EAAQnC,SAASP,QAEtDuD,EAAaL,KAAK,CACdnD,IAAK2C,EAAQ3C,IACbC,OAAQ0C,EAAQ1C,SAIxB,OAAOuD,GCzIJ,SAASM,EAAaJ,EAAMd,EAAQE,GACvC,IAAI9C,EAAM0D,EAAK1D,IACXC,EAASyD,EAAKzD,OACd0D,EAAW,GAkCf,OA5BG1D,EAAO,GAAK,GACX0D,EAASR,KAAK,CACVnD,IAAKA,EACLC,OAAQA,EAAO,IAIpBD,EAAI,GAAK,GACR2D,EAASR,KAAK,CACVnD,IAAKA,EAAI,EACTC,OAAQA,IAIbA,EAAO,EAAI6C,GACVa,EAASR,KAAK,CACVnD,IAAKA,EACLC,OAAQA,EAAO,IAIpBD,EAAI,EAAI4C,GACPe,EAASR,KAAK,CACVnD,IAAKA,EAAI,EACTC,OAAQA,IAIT0D,EAKJ,IAAMF,EAAkB,SAACnB,EAAMsB,GAClC,IAAIjB,EAAUL,EAAKsB,EAAW5D,KAAK4D,EAAW3D,QAC1CuD,EAAe,GAOnB,IALAA,EAAaL,KAAK,CACdnD,IAAK4D,EAAW5D,IAChBC,OAAQ2D,EAAW3D,cAGI4D,IAArBlB,EAAQnC,UAEVmC,EAAUL,EAAKK,EAAQnC,SAASR,KAAK2C,EAAQnC,SAASP,QAEtDuD,EAAaL,KAAK,CACdnD,IAAK2C,EAAQ3C,IACbC,OAAQ0C,EAAQ1C,SAIxB,OAAOuD,GCzDJ,SAASO,EAAIzB,EAAMC,EAAUyB,EAAUvB,EAAQwB,GAElD,IAAIrB,EAASN,EAAKO,OACdqB,EAAS5B,EAAK,GAAGO,OACjBE,EAAeT,EAAKC,GAAUyB,GAC9BG,EAAQ,GACRlB,EAAU,GA8Bd,IARAF,EAAaG,WAAY,EACzBD,EAAQE,KAAK,CACTnD,IAAKuC,EACLtC,OAAQ+D,IAEZG,EAAMhB,KAAKJ,GAGLoB,EAAMtB,QAAO,CAEf,IAAIuB,EAAcD,EAAME,MASxB,IAR6B,IAA1BD,EAAYlB,YACXkB,EAAYlB,WAAY,EACxBD,EAAQE,KAAK,CACTnD,IAAKoE,EAAYpE,IACjBC,OAAQmE,EAAYnE,UAIzBwC,IAAW2B,EAAYpE,KAAOiE,IAAWG,EAAYnE,OAKpD,MAAO,CACHuD,aAHeC,EAAgBnB,EAAMA,EAAK8B,EAAYpE,KAAKoE,EAAYnE,SAIvEgD,QAASA,GAOjB,IAFA,IAAII,EAAYS,EAAaM,EAAaxB,EAAQsB,GAE1CX,EAAI,EAAGA,EAAIF,EAAUR,OAAQU,IAAI,CACrC,IAAIvD,EAAMqD,EAAUE,GAAGvD,IACnBC,EAASoD,EAAUE,GAAGtD,OAEvBqC,EAAKtC,GAAKC,GAAQiD,YAGlBZ,EAAKtC,GAAKC,GAAQc,SAIrBoD,EAAMhB,KAAKb,EAAKtC,GAAKC,IAErBqC,EAAKtC,GAAKC,GAAQO,SAAW,CACzBR,IAAKoE,EAAYpE,IACjBC,OAAQmE,EAAYnE,Y,IC+ErBqE,EA/JX,aAAc,IAAD,gCAIbC,SAAW,SAACb,GACJ,EAAKV,MAAMwB,SAASd,IAGpB,EAAKV,MAAMG,KAAKO,GAQpB,IAHA,IAAIe,EAAa,EAAKzB,MAAMH,OAAS,EACjCuB,EAAc,EAAKpB,MAAMyB,GAEvBA,EAAa,GAAE,CAEjB,IAAIC,EAAYC,KAAKC,OAAOH,EAAW,GAAG,GACtCI,EAAS,EAAK7B,MAAM0B,GAExB,GAAGN,EAAY7D,SAAWsE,EAAOtE,SAAU,MAC3C,EAAKyC,MAAM0B,GAAaN,EACxB,EAAKpB,MAAMyB,GAAcI,EAEzBJ,EAAaC,IAzBR,KA8BbI,eAAiB,SAACpB,GACV,EAAKV,MAAMwB,SAASd,IAGpB,EAAKV,MAAMG,KAAKO,GAQpB,IAHA,IAAIe,EAAa,EAAKzB,MAAMH,OAAS,EACjCuB,EAAc,EAAKpB,MAAMyB,GAEvBA,EAAa,GAAE,CAEjB,IAAIC,EAAYC,KAAKC,OAAOH,EAAW,GAAG,GACtCI,EAAS,EAAK7B,MAAM0B,GAExB,GAAGN,EAAYW,OAASF,EAAOE,OAAQ,MACvC,EAAK/B,MAAM0B,GAAaN,EACxB,EAAKpB,MAAMyB,GAAcI,EAEzBJ,EAAaC,IAnDR,KAuDbM,QAAU,WAEN,IAAIC,EAAgB,EAAKjC,MAAM,GAC3BkC,EAAe,EAAKlC,MAAMqB,MAO9B,OALG,EAAKrB,MAAMH,OAAS,IACnB,EAAKG,MAAM,GAAKkC,EAChB,EAAKC,YAGFF,GAjEE,KAoEbE,SAAW,WAKP,IAJA,IAAIV,EAAa,EACb5B,EAAS,EAAKG,MAAMH,OACpBuB,EAAc,EAAKpB,MAAM,KAElB,CAEP,IAAIoC,EAAU,EAAIX,EAAa,EAC3BY,EAAW,EAAIZ,EAAa,EAC5Ba,OAAI,EAAEC,OAAK,EACXC,EAAO,KAkBX,GAhBGJ,EAAUvC,IACTyC,EAAO,EAAKtC,MAAMoC,GACfhB,EAAY7D,SAAW+E,EAAK/E,WAC3BiF,EAAOJ,IAGZC,EAAWxC,IACV0C,EAAQ,EAAKvC,MAAMqC,IAEdjB,EAAY7D,SAAWgF,EAAMhF,UAAqB,OAATiF,GAEhC,OAATA,GAAiBD,EAAMhF,SAAW+E,EAAK/E,YACpCiF,EAAOH,IAIP,OAATG,EAAe,MAClB,IAAIC,EAAY,EAAKzC,MAAMwC,GAC3B,EAAKxC,MAAMyB,GAAcgB,EACzB,EAAKzC,MAAMwC,GAAQpB,EACnBK,EAAae,IApGR,KA0GbE,cAAgB,WAEZ,IAAIT,EAAgB,EAAKjC,MAAM,GAC3BkC,EAAe,EAAKlC,MAAMqB,MAO9B,OALG,EAAKrB,MAAMH,OAAS,IACnB,EAAKG,MAAM,GAAKkC,EAChB,EAAKS,kBAGFV,GApHE,KAwHbU,eAAiB,WAKb,IAJA,IAAIlB,EAAa,EACb5B,EAAS,EAAKG,MAAMH,OACpBuB,EAAc,EAAKpB,MAAM,KAElB,CAEP,IAAIoC,EAAU,EAAIX,EAAa,EAC3BY,EAAW,EAAIZ,EAAa,EAC5Ba,OAAI,EAAEC,OAAK,EACXC,EAAO,KAkBX,GAhBGJ,EAAUvC,IACTyC,EAAO,EAAKtC,MAAMoC,GACfhB,EAAYW,OAASO,EAAKP,SACzBS,EAAOJ,IAGZC,EAAWxC,IACV0C,EAAQ,EAAKvC,MAAMqC,IAEdjB,EAAYW,OAASQ,EAAMR,QAAmB,OAATS,GAE5B,OAATA,GAAiBD,EAAMR,OAASO,EAAKP,UAClCS,EAAOH,IAIP,OAATG,EAAe,MAClB,IAAIC,EAAY,EAAKzC,MAAMwC,GAC3B,EAAKxC,MAAMyB,GAAcgB,EACzB,EAAKzC,MAAMwC,GAAQpB,EACnBK,EAAae,IAvJjB9D,KAAKsB,MAAQ,ICsFN4C,EArFE,SAACtD,EAAMC,EAAUC,EAAaC,EAAQC,GAEnD,IAOI0B,EACAf,EARAT,EAASN,EAAKO,OACdqB,EAAS5B,EAAK,GAAGO,OACjBE,EAAeT,EAAKC,GAAUC,GAC9BQ,EAAQ,IAAIsB,EACZrB,EAAU,GAMd,IALAF,EAAaxC,SAAW,EACxByC,EAAMuB,SAASxB,GAITC,EAAMA,MAAMH,QAEd,KADAuB,EAAcpB,EAAMgC,WACLjE,OAAf,CAEAsC,EAAYS,EAAaM,EAAaxB,EAAQsB,IACjB,IAA1BE,EAAYlB,YACXkB,EAAYlB,WAAY,EACxBD,EAAQE,KAAK,CACTnD,IAAKoE,EAAYpE,IACjBC,OAAQmE,EAAYnE,UAI5B,IAAI,IAAIsD,EAAI,EAAGA,EAAIF,EAAUR,OAAQU,IAGjC,IAAGjB,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQiD,YAE5CZ,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQc,OAA/C,CAYA,QAV4D8C,IAAzDvB,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,WAC3C8B,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAAW,CACnDR,IAAKoE,EAAYpE,IACjBC,OAAQmE,EAAYnE,SAOzBqC,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAASR,MAAQoE,EAAYpE,KACrEsC,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAASP,SAAWmE,EAAYnE,OAClF,CACG,IAAI4F,EAAUvD,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAASR,IAC/D8F,EAAaxD,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAASP,OAClEO,EAAW8B,EAAKuD,GAASC,GAE1BtF,EAASD,WAAa6D,EAAY7D,UAC9BC,EAASD,SAAW6D,EAAY7D,WAC/B+B,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAAW,CACnDR,IAAK6F,EACL5F,OAAQ6F,IAgBxB,GAPGxD,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQiB,SAC3CoB,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQM,SAAW,GAAK+B,EAAKA,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAASR,KAAKsC,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAASP,QAAQM,SAGxL+B,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQM,SAAW,EAAI+B,EAAKA,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAASR,KAAKsC,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAASP,QAAQM,SAGxL6D,EAAYpE,MAAQyC,GAAU2B,EAAYnE,SAAWyC,EAEpD,MAAO,CACHO,QAASA,EACTO,aAHeC,EAAgBnB,EAAMA,EAAKG,GAAQC,KAO1DM,EAAMuB,SAASjC,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,YCKzD8F,EAAoB,SAAC/F,EAAKC,EAAQwC,EAAQC,GAW5C,OAFmBiC,KAAKqB,IAAIhG,EAAMyC,GAAUkC,KAAKqB,IAAI/F,EAASyC,IAKnDuD,EA7Fe,SAAC3D,EAAMC,EAAUC,EAAaC,EAAQC,GAChE,IAUI0B,EAVApB,EAAQ,IAAIsB,EAOZ1B,EAASN,EAAKO,OACdC,EAAYR,EAAK,GAAGO,OACpBE,EAAeT,EAAKC,GAAUC,GAE9BS,EAAU,GAMd,IAHAF,EAAaxC,SAAW,EACxByC,EAAMuB,SAASxB,GAETC,EAAMA,MAAMH,QAAO,EAEQ,KAD7BuB,EAAcpB,EAAMgC,WACL9B,YACXkB,EAAYlB,WAAY,EACxBD,EAAQE,KAAK,CACTnD,IAAKoE,EAAYpE,IACjBC,OAAQmE,EAAYnE,UAM5B,IAFA,IAAIoD,EAAYS,EAAaM,EAAaxB,EAAQE,GAE1CS,EAAI,EAAGA,EAAIF,EAAUR,OAAQU,IAAI,CAErC,IAAI2C,EAAW7C,EAAUE,GAAGvD,IACxBmG,EAAW9C,EAAUE,GAAGtD,OACxBM,EAAWwF,EAAkBG,EAAUC,EAAU1D,EAAQC,GAG7D,IAAGJ,EAAK4D,GAAUC,GAAUpF,SACzBuB,EAAK4D,GAAUC,GAAUjD,UAA5B,CAgBA,GAbAZ,EAAK4D,GAAUC,GAAU3F,SAAW,CAChCR,IAAKoE,EAAYpE,IACjBC,OAAQmE,EAAYnE,QAIrBqC,EAAK4D,GAAUC,GAAUjF,SACxBoB,EAAK4D,GAAUC,GAAU5F,SAAWA,EAAW,GAG/C+B,EAAK4D,GAAUC,GAAU5F,SAAWA,EAGrC6D,EAAYpE,MAAQyC,GAAU2B,EAAYnE,SAAWyC,EAEpD,MAAO,CACHO,QAASA,EACTO,aAHeC,EAAgBnB,EAAMA,EAAKG,GAAQC,KAQ1DM,EAAMuB,SAASjC,EAAK4D,GAAUC,QC2BpCJ,EAAoB,SAAC/F,EAAKC,EAAQwC,EAAQC,GAW5C,OAFmBiC,KAAKqB,IAAIhG,EAAMyC,GAAUkC,KAAKqB,IAAI/F,EAASyC,IAKnD0D,EA3GK,SAAC9D,EAAMC,EAAUC,EAAaC,EAAQC,GACtD,IAOI0B,EACAf,EARAT,EAASN,EAAKO,OACdqB,EAAS5B,EAAK,GAAGO,OACjBE,EAAeT,EAAKC,GAAUC,GAC9BQ,EAAQ,IAAIsB,EACZrB,EAAU,GAMd,IALAF,EAAaxC,SAAW,EACxByC,EAAM8B,eAAe/B,GAIfC,EAAMA,MAAMH,QAEd,KADAuB,EAAcpB,EAAM0C,iBACL3E,OAAf,CAEAsC,EAAYS,EAAaM,EAAaxB,EAAQsB,IACjB,IAA1BE,EAAYlB,YACXkB,EAAYlB,WAAY,EACxBD,EAAQE,KAAK,CACTnD,IAAKoE,EAAYpE,IACjBC,OAAQmE,EAAYnE,UAK5B,IAAI,IAAIsD,EAAI,EAAGA,EAAIF,EAAUR,OAAQU,IAAI,CAErC,IAAI8C,EAAYN,EAAkB1C,EAAUE,GAAGvD,IAAKqD,EAAUE,GAAGtD,OAAQwC,EAAQC,GAC7E4D,OAAe,EAGnB,IAAGhE,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQiD,YAE5CZ,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQc,OAA/C,CAYA,QAV4D8C,IAAzDvB,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,WAC3C8B,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAAW,CACnDR,IAAKoE,EAAYpE,IACjBC,OAAQmE,EAAYnE,SAOzBqC,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAASR,MAAQoE,EAAYpE,KACrEsC,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAASP,SAAWmE,EAAYnE,OAClF,CACG,IAAI4F,EAAUvD,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAASR,IAC/D8F,EAAaxD,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAASP,OAClEO,EAAW8B,EAAKuD,GAASC,GAE1BtF,EAASD,WAAa6D,EAAY7D,UAC9BC,EAASD,SAAW6D,EAAY7D,WAC/B+B,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAAW,CACnDR,IAAK6F,EACL5F,OAAQ6F,IAqBxB,GAZGxD,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQiB,UAE3CoF,EAAkB,GAAKhE,EAAKA,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAASR,KAAKsC,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAASP,QAAQM,SACnJ+B,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQM,SAAW+F,EACvDhE,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQ8E,OAASuB,EAAkBD,IAGvEC,EAAkB,EAAIhE,EAAKA,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAASR,KAAKsC,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQO,SAASP,QAAQM,SAClJ+B,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQM,SAAW+F,EACvDhE,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,QAAQ8E,OAASuB,EAAkBD,GAGxEjC,EAAYpE,MAAQyC,GAAU2B,EAAYnE,SAAWyC,EAEpD,MAAO,CACHO,QAASA,EACTO,aAHeC,EAAgBnB,EAAMA,EAAKG,GAAQC,KAO1DM,EAAM8B,eAAexC,EAAKe,EAAUE,GAAGvD,KAAKqD,EAAUE,GAAGtD,aCvDtDsG,EAjCO,SAACjE,EAAMkE,EAAOC,GAMhC,IAJA,IAAIC,EAAY,GAIPnD,EAAI,EAAGA,EAAIiD,EAAOjD,IAEvBmD,EAAUvD,KAAK,CACXnD,IAAK,EACLC,OAAQsD,IAEZmD,EAAUvD,KAAK,CACXnD,IAAKyG,EAAO,EACZxG,OAAQsD,IAKhB,IAAK,IAAIoD,EAAI,EAAGA,EAAIF,EAAQE,IACxBD,EAAUvD,KAAK,CACXnD,IAAK2G,EACL1G,OAAQ,IAEZyG,EAAUvD,KAAK,CACXnD,IAAK2G,EACL1G,OAAQuG,EAAM,IAItB,OAAOE,GC2HIE,EAxJW,SAApBA,EAAqBtE,EAAMuE,EAAUC,EAAUC,EAAWC,GAK5D,IAGIC,EAHAP,EAAY,GAIZQ,EAAcJ,EAAWD,EAAU,EACnCM,EAAeH,EAAYD,EAAW,EAiB1C,GAAGG,GAAa,GAAKC,GAAc,EAC/B,OAAOT,EAGX,GAzBe,cASXO,EADDC,EAAaC,EARD,WACE,cAwBW,CACxB,IAEIC,EACAC,EACAC,EACAC,EALAC,EAAoB,GACpBC,EAAc,GAKlB9H,QAAQC,IAAI,SACZD,QAAQC,IAAI,iBACZD,QAAQC,IAAI,SAGZ,IAAI,IAAI2D,EAAIsD,EAAUtD,GAAKuD,EAAUvD,GAAG,EACpCiE,EAAkBrE,KAAKI,GAI3B,IAAI,IAAIoD,EAAII,EAAU,EAAGJ,GAAKK,EAAU,EAAGL,GAAG,EAC1Cc,EAAYtE,KAAKwD,GAGrBS,EAAkBzC,KAAKC,MAAMD,KAAK+C,SAAWF,EAAkB3E,QAC/DwE,EAAe1C,KAAKC,MAAMD,KAAK+C,SAAWD,EAAY5E,QAEtDyE,EAAiBE,EAAkBJ,GACnCG,EAAqBE,EAAYJ,GAKjC,IAHA,IACIM,EAAgBX,EAAY,EAExBzD,EAHYwD,EAAY,EAGLxD,GAAKoE,EAAepE,IACxCA,IAAMgE,IACTb,EAAUvD,KAAK,CACXnD,IAAKuD,EACLtD,OAAQqH,IAEZhF,EAAKiB,GAAG+D,GAAgBvG,QAAS,GAIrCpB,QAAQC,IAAI,QACZD,QAAQC,IAAI,YAEZD,QAAQC,IAAI,aAAeiH,GAC3BlH,QAAQC,IAAI,cAAgB0H,EAAiB,IAC7C3H,QAAQC,IAAI,cAAgBmH,GAC5BpH,QAAQC,IAAI,cAAgBoH,GAE5BrH,QAAQC,IAAI,QACZD,QAAQC,IAAI,cAAgB0H,EAAiB,IAC7C3H,QAAQC,IAAI,aAAekH,GAC3BnH,QAAQC,IAAI,cAAgBmH,GAC5BpH,QAAQC,IAAI,cAAgBoH,GAG5BN,GADAA,EAAYA,EAAUkB,OAAOhB,EAAkBtE,EAAMuE,EAAUS,EAAe,EAAGP,EAAWC,KACtEY,OAAOhB,EAAkBtE,EAAMgF,EAAe,EAAGR,EAAUC,EAAWC,SAK3F,GApFY,eAoFTC,EAA2B,CAQ/B,IAPA,IAEIY,EACAC,EACAC,EACAC,EALAC,EAAiB,GACjBC,EAAgB,GAMZ3E,EAAIwD,EAAWxD,GAAIyD,EAAWzD,GAAG,EACrC0E,EAAe9E,KAAKI,GAGxB,IAAI,IAAIoD,EAAIE,EAAS,EAAGF,GAAKG,EAAS,EAAGH,GAAG,EACxCuB,EAAc/E,KAAKwD,GAGvBkB,EAAalD,KAAKC,MAAMD,KAAK+C,SAAWO,EAAepF,QACvDiF,EAAgBnD,KAAKC,MAAMD,KAAK+C,SAAWQ,EAAcrF,QAEzDkF,EAAcE,EAAeJ,GAC7BG,EAAwBE,EAAcJ,GAEtC,IAAIK,EAAetB,EAAW,EAC1BuB,EAAetB,EAAW,EAE9BnH,QAAQC,IAAIoI,GAEZ,IAAI,IAAIzE,EAAI4E,EAAc5E,GAAK6E,EAAc7E,IACtCA,IAAMyE,IACT1F,EAAKyF,GAAaxE,GAAGxC,QAAS,EAC9B2F,EAAUvD,KAAK,CACXnD,IAAK+H,EACL9H,OAAQsD,KAGhB5D,QAAQC,IAAI,iBAAmBmI,GAE/BpI,QAAQC,IAAI,QACZD,QAAQC,IAAI,YAEZD,QAAQC,IAAI,aAAeiH,GAC3BlH,QAAQC,IAAI,aAAekH,GAC3BnH,QAAQC,IAAI,cAAgBmH,GAC5BpH,QAAQC,IAAI,eAAiBmI,EAAY,IACzCpI,QAAQC,IAAI,WAEZD,QAAQC,IAAI,aAAeiH,GAC3BlH,QAAQC,IAAI,aAAekH,GAC3BnH,QAAQC,IAAI,eAAiBmI,EAAY,IACzCpI,QAAQC,IAAI,cAAgBoH,GAG5BN,GADAA,EAAYA,EAAUkB,OAAOhB,EAAkBtE,EAAMuE,EAAUC,EAAUC,EAAWgB,EAAY,KAC1EH,OAAOhB,EAAkBtE,EAAMuE,EAAUC,EAAUiB,EAAY,EAAGf,IAK5F,OAAON,GCrJE2B,EAAY,uBACZC,EAAU,qBAEVC,EAAY,2BC2BVC,EA1BU,SAACC,EAAcC,GAcpC,IAbA,IAAIC,GAAa,EAaTpF,EAAI,EAAGA,EAAIkF,EAAa5F,OAAQU,IACjCkF,EAAalF,GAAGvD,MAAQ0I,EAAU1I,KAClCyI,EAAalF,GAAGtD,SAAWyI,EAAUzI,SACpC0I,GAAa,GAKrB,OAAOA,GCRLC,E,2MAEFrJ,MAAQ,CACJ+C,KAAM,GACNC,SAAU,KACVC,YAAa,KACbC,OAAQ,KACRC,UAAW,KACXmG,YAAQhF,EACRL,aAAc,GACdP,QAAS,GACT6F,QAAS,GACTC,MAAO,I,EAIXC,mBAAqB,WACjB,IAAI1G,EAAO,EAAK2G,oBAChB,EAAKtI,SAAS,CAAC2B,U,EAGnB4G,WAAa,SAAClJ,EAAKC,GACf,IAAI6I,EAAU,EAAKvJ,MAAMuJ,QACrBC,EAAQ,EAAKxJ,MAAMwJ,MACnBI,EAAe,CACfnJ,IAAKA,EACLC,OAAQA,GAWZ,IAR+C,IAA5CuI,EAAiBM,EAASK,IAIzBL,EAAQ3F,KAAKgG,IAI4B,IAA1CX,EAAiBO,EAAOI,GAAuB,CAW9C,IAAIC,EAAWL,EAAMM,QAAO,SAAUC,GAClC,OAAOA,EAAKtJ,MAAQmJ,EAAanJ,KACjCsJ,EAAKrJ,SAAWkJ,EAAalJ,UAEjC,EAAKU,SAAS,CAACoI,MAAOK,M,EAM9BG,QAAU,SAACvJ,EAAKC,GACZ,IAAI6I,EAAU,EAAKvJ,MAAMuJ,QACrBC,EAAQ,EAAKxJ,MAAMwJ,MACnBI,EAAe,CACfnJ,IAAKA,EACLC,OAAQA,GAMZ,IAH6C,IAA1CuI,EAAiBO,EAAOI,IACvBJ,EAAM5F,KAAKgG,IAEgC,IAA5CX,EAAiBM,EAASK,GAAuB,CAChD,IAAIK,EAAaV,EAAQO,QAAO,SAAUI,GACtC,OAAOA,EAAWzJ,MAAQmJ,EAAanJ,KACvCyJ,EAAWxJ,SAAWkJ,EAAalJ,UAEvC,EAAKU,SAAS,CAACmI,QAASU,M,EAMhCnJ,YAAc,SAACL,EAAKC,EAAQf,GACxB,IAAIoD,EAAO,EAAK/C,MAAM+C,KAGnBpD,IAAeL,EACdyD,EAAKtC,GAAKC,GAAQe,SAAU,EAExB9B,IAAeJ,EACnBwD,EAAKtC,GAAKC,GAAQgB,OAAQ,EAGtB/B,IAAeH,GACnBuD,EAAKtC,GAAKC,GAAQc,QAAS,EAC3BuB,EAAKtC,GAAKC,GAAQiB,UAAW,EAC7B,EAAKgI,WAAWlJ,EAAKC,IAIjBf,IAAeF,IACnBsD,EAAKtC,GAAKC,GAAQc,QAAS,EAC3BuB,EAAKtC,GAAKC,GAAQiB,UAAW,EAC7B,EAAKqI,QAAQvJ,EAAKC,IAGtB,EAAKU,SAAS,CAAC2B,KAAMA,K,EAGzBoH,UAAY,WACR,IAAIpH,EAAO,EAAK2G,oBAChB,EAAKtI,SAAS,CAAC2B,SACf,EAAK3B,SAAS,CAACmI,QAAS,KACxB,EAAKnI,SAAS,CAACoI,MAAO,KACV,EAAKxJ,MAAM0D,QAMvB,EAAK1D,MAAM0D,QAAQ0G,SAAQ,SAAAjG,GACvB9C,SAASC,eAAT,eAAgC6C,EAAK1D,IAArC,YAA4C0D,EAAKzD,SAAUkB,UAAY,UAG3E,EAAKtB,MAAM+J,qBACX,EAAK/J,MAAMZ,aAAaJ,I,EAI5BgL,YAAc,WAmBV,IAfA,IAUIC,EAVAxH,EAAO,EAAK2G,oBACZc,EAAQ,EAAKxK,MAAM0D,QAKnBV,EAAW,EAAK1C,MAAMK,cAAc8J,aAAahK,IACjDwC,EAAc,EAAK3C,MAAMK,cAAc8J,aAAa/J,OACpDwC,EAAS,EAAK5C,MAAMK,cAAc+J,WAAWjK,IAC7C0C,EAAY,EAAK7C,MAAMK,cAAc+J,WAAWhK,OAEhDiK,EAAQ,EAIJ3G,EAAK,EAAGA,EAAI,EAAKhE,MAAM0D,QAAQJ,OAAQU,IAC3C3C,SAASC,eAAT,eAAgCkJ,EAAMxG,GAAGvD,IAAzC,YAAgD+J,EAAMxG,GAAGtD,SAAUkB,UAAY,OAYnF,GATG,EAAKtB,MAAMK,cAAcC,mBACxBmC,EAAKC,GAAUC,GAAaxB,SAAU,GAGvC,EAAKnB,MAAMK,cAAcI,iBACxBgC,EAAKG,GAAQC,GAAWzB,OAAQ,GAIjC,EAAK1B,MAAMuJ,QAAQjG,OAAS,EAC3B,IAAQU,EAAI,EAAGA,EAAI,EAAKhE,MAAMuJ,QAAQjG,OAAQU,IAC1CjB,EAAK,EAAK/C,MAAMuJ,QAAQvF,GAAGvD,KAAK,EAAKT,MAAMuJ,QAAQvF,GAAGtD,QAAQiB,UAAW,EAKjF,GAAG,EAAK3B,MAAMwJ,MAAMlG,OAAS,EACzB,IAAI,IAAI8D,EAAI,EAAGA,EAAI,EAAKpH,MAAMwJ,MAAMlG,OAAQ8D,IACxCrE,EAAK,EAAK/C,MAAMwJ,MAAMpC,GAAG3G,KAAK,EAAKT,MAAMwJ,MAAMpC,GAAG1G,QAAQc,QAAS,EAQ3E,GAJA,EAAKJ,SAAS,CAAC2B,SAIX,EAAKzC,MAAMK,cAAc8J,aAAahK,KAAQ,EAAKH,MAAMK,cAAc+J,WAAWjK,IAKlF,IAGG,EAAKH,MAAMsK,aAAaA,eAAiB9B,GACxCyB,EAAazH,EAAI,EAAK9C,MAAM+C,KAAMC,EAAUC,EAAaC,EAAQC,GAEjE,EAAK/B,SAAS,CAACsC,QAAS6G,EAAW7G,WAE/B,EAAKpD,MAAMsK,aAAaA,eAAiB7B,GAC7CwB,EAAa/F,EAAI,EAAKxE,MAAM+C,KAAMC,EAAUC,EAAaC,EAAQC,GAEjE,EAAK/B,SAAS,CAACsC,QAAS6G,EAAW7G,WFhNvB,yBEkNR,EAAKpD,MAAMsK,aAAaA,cAC5BL,EAAalE,EAAS,EAAKrG,MAAM+C,KAAMC,EAAUC,EAAaC,EAAQC,GAEtE,EAAK/B,SAAS,CAACsC,QAAS6G,EAAW7G,WAE/B,EAAKpD,MAAMsK,aAAaA,eAAiB5B,GAC7CuB,EAAa7D,EAAsB,EAAK1G,MAAM+C,KAAMC,EAAUC,EAAaC,EAAQC,GAEnF,EAAK/B,SAAS,CAACsC,QAAS6G,EAAW7G,WFxNpB,wBE0NX,EAAKpD,MAAMsK,aAAaA,eAC5BL,EAAa1D,EAAY,EAAK7G,MAAM+C,KAAMC,EAAUC,EAAaC,EAAQC,GACzE,EAAK/B,SAAS,CAACsC,QAAS6G,EAAW7G,WAGvC6G,EAAW7G,QAAQ0G,SAAQ,SAAAjG,GACvBwG,GAAQ,EAERE,YAAW,WAEPxJ,SAASC,eAAT,eAAgC6C,EAAK1D,IAArC,YAA4C0D,EAAKzD,SAAUkB,UAAY,sBAEhE,EAAR+I,MAGPJ,EAAWtG,aAAa6G,UAExBP,EAAWtG,aAAamG,SAAQ,SAAAjG,GAC5BwG,GAAO,EACPE,YAAW,WACPxJ,SAASC,eAAT,eAAgC6C,EAAK1D,IAArC,YAA4C0D,EAAKzD,SAAUkB,UAAY,mBAChE,EAAR+I,MAIP,SACII,MAAM,8BArDVA,MAAM,gF,EA4DdC,aAAe,WAMX5K,QAAQC,IAAI,mBACZD,QAAQC,IAAI,qBACZD,QAAQC,IAAI,mBAGZ,IAAIkH,EAAW,EAAKvH,MAAM+C,KAAK,GAAGO,OAClClD,QAAQC,IAAIkH,GACZnH,QAAQC,IAAI,KACZ,IAAIoH,EAAY,EAAKzH,MAAM+C,KAAKO,OAChClD,QAAQC,IAAIoH,GACZrH,QAAQC,IAAI,KACZ,IAAI4K,EAAW,EAAKjL,MAAM+C,KACtBmI,EAAYlE,EAAc,EAAKhH,MAAM+C,KAAMwE,EAAUE,GAEzDyD,EAAUd,SAAQ,SAAAe,GACdF,EAASE,EAAK1K,KAAK0K,EAAKzK,QAAQc,QAAS,KAG7C,EAAKJ,SAAS,CAAC2B,KAAMkI,IAErB,IAAIG,EAAa/D,EAAkB,EAAKrH,MAAM+C,KAAM,EAAGwE,EAAS,EAAG,EAAGE,EAAU,GAIhFyD,EAAYA,EAAU7C,OAAO+C,GAE7B,EAAKhK,SAAS,CAACoI,MAAO0B,K,EA2D1BxB,kBAAoB,WAShB,IAPA,IACI7E,EADA9B,EAAO,GAEPkE,EAAQ7B,KAAKiG,MAAMC,OAAOC,WAAa,IAKnCvH,EAAI,EAAGA,EAJF,GAIcA,IAAI,CAE3B,IADA,IAAIwH,EAAW,GACPpE,EAAI,EAAGA,EAAIH,EAAOG,IAEtBvC,EAAc,EAAK4G,WAAWzH,EAAGoD,GACjCoE,EAAS5H,KAAKiB,GAElB9B,EAAKa,KAAK4H,GAGd,OAAOzI,G,EAKX0I,WAAa,SAAChL,EAAKC,GAEf,MAAO,CACHD,IAAKA,EACLC,OAAQA,EACRsC,cAAUsB,EACVrB,iBAAaqB,EACbX,WAAW,EACXvB,QAAQ,EACRnB,cAAUqD,EACV7C,SAAS,EACTC,OAAO,EACPF,QAAQ,EACRR,SAAU0K,IACV/J,UAAU,EACV6D,OAAQkG,M,wEA7FP,IAODC,EAPA,OAaJ,OAXAL,OAAOM,SAAW,WACd,IAAI7I,EAAO,EAAK2G,oBAChB,EAAKtI,SAAS,CAAC2B,UAKhBZ,KAAK7B,MAAMsK,aAAaA,eACvBe,EAAa,4BAAQ/J,UAAU,SAAS/B,KAAK,SAASyC,QAASH,KAAKmI,aAAvD,OAAyEnI,KAAK7B,MAAMsK,aAAaA,eAI9G,yBAAKhJ,UAAU,QACV+J,EACD,4BAAQ/J,UAAU,SAAS/B,KAAK,SAASyC,QAASH,KAAKgI,WAAvD,cACA,4BAAQvI,UAAU,SAAS/B,KAAK,SAASyC,QAASH,KAAK6I,cAAvD,eAEI7I,KAAKnC,MAAM+C,KAAK8I,KAAI,SAACL,EAAUM,GAC3B,OACI,yBAAK/J,IAAK+J,EAAQlK,UAAWmK,IAAOP,UAG5BA,EAASK,KAAI,SAAC1H,EAAM6H,GAChB,OAAO,kBAAC,EAAD,CACHjK,IAAKiK,EACLvL,IAAK0D,EAAK1D,IACVC,OAAQyD,EAAKzD,OACbsC,SAAUmB,EAAKnB,SACfC,YAAakB,EAAKlB,YAClBU,UAAWQ,EAAKR,UAChBvB,OAAQ+B,EAAK/B,OACbnB,SAAUkD,EAAKlD,SACfH,YAAa,EAAKA,YAClBW,QAAS0C,EAAK1C,QACdC,MAAOyC,EAAKzC,MACZF,OAAQ2C,EAAK3C,OACbR,SAAUmD,EAAKnD,SACfW,SAAUwC,EAAKxC,SACf6D,OAAQrB,EAAKqB,qB,GA1TtC5C,aA4XJC,eAPS,SAAC7C,GACrB,MAAO,CACHW,cAAeX,EAAMW,cACrBiK,aAAc5K,EAAM4K,gBAIY,CACpCP,mBdvV8B,kBAAM,SAAAzK,GACpCA,EAAS,CACLC,KCvD4B,2Ba6YhCH,aAAcA,GAFHmD,CAGZwG,GCzYG4C,G,mBAcF,WAAY3L,GAAQ,IAAD,8BACf,4CAAMA,KAGV4L,iBAAmB,WAEf9L,QAAQC,IAAI,EAAK8L,YAAYC,WAElB,EAAKD,aARD,EAYnBE,kBAAoB,WAEhB,EAAK/L,MAAMZ,aAAa,yBAdT,EAiBnB4M,gBAAkB,WACd,EAAKhM,MAAMZ,aAAaH,IAlBT,EAqBnBgN,oBAAsB,WAClB,EAAKjM,MAAMZ,aAAaF,IAtBT,EAyBnBgN,iBAAmB,WACf,EAAKlM,MAAMZ,aAAaD,IA1BT,EA6BnBgN,cAAgB,WACZ,EAAKnM,MAAMoM,gBAAgB5D,IA9BZ,EAiCnB6D,cAAgB,WACZ,EAAKrM,MAAMoM,gBAAgB3D,IAlCZ,EAqCnB6D,mBAAqB,WACjB,EAAKtM,MAAMoM,gBH1DS,yBGoBL,EAyCnBG,gBAAkB,WACd,EAAKvM,MAAMoM,gBAAgB1D,IA1CZ,EA6CnB8D,gBAAkB,WACd,EAAKxM,MAAMoM,gBHhEY,wBGkBR,EAiDnBK,WAAa,WACT,EAAKzM,MAAMZ,ahBpEO,YgBkBH,E,sEAqDV,IAAD,OAEJ,OACI,yBAAKkC,UAAU,UAEX,yBAAKA,UAAU,yBACX,yBAAKA,UAAU,gBACX,uBAAGA,UAAU,cAAcoL,KAAK,oBAC5B,yBAAKC,IAAI,yCAAyCC,IAAI,iDAAiDjG,MAAM,MAAMC,OAAO,QAE9H,yBAAKtF,UAAU,uBAAuBuL,cAAY,mCAC9C,+BACA,+BACA,iCAIR,yBAAK9K,GAAG,kCAAkCT,UAAU,eAChD,yBAAKA,UAAU,gBACX,uBAAGA,UAAU,cAAcoL,KAAK,qBAAhC,QAGA,yBAAKpL,UAAU,yCAEX,uBAAGA,UAAU,eAAb,UAIA,yBAAKA,UAAU,4BACX,yBAAKwL,IAAK,SAACC,GACP,EAAKlB,YAAckB,GAEnBzL,UAAU,4BACVU,QAASH,KAAKkK,mBAEd,uBAAGzK,UAAU,6BANjB,SAUA,yBAAKwL,IAAK,SAACC,GACP,EAAKC,UAAYD,GAEjBzL,UAAU,4BACVU,QAASH,KAAKmK,iBAGd,uBAAG1K,UAAU,6BAPjB,OAWA,yBACIA,UAAU,4BACVU,QAASH,KAAKoK,qBAEd,uBAAG3K,UAAU,4BAJjB,WAOA,yBACIA,UAAU,4BACVU,QAASH,KAAKqK,kBAEd,uBAAG5K,UAAU,4BAJjB,QAOA,yBACIA,UAAU,4BACVU,QAASH,KAAK4K,YAEd,uBAAGnL,UAAU,4BAJjB,iBASR,yBAAKA,UAAU,yCACX,uBAAGA,UAAU,eAAb,aAGA,yBAAKA,UAAU,4BACX,yBACIA,UAAU,4BACVU,QAASH,KAAKsK,eAFlB,wBAMA,yBACI7K,UAAU,4BACVU,QAASH,KAAKwK,eAFlB,sBAMA,yBACI/K,UAAU,4BACVU,QAASH,KAAKyK,oBAFlB,wBAMA,yBACIhL,UAAU,4BACVU,QAASH,KAAK0K,iBAFlB,4BAMA,yBACIjL,UAAU,4BACVU,QAASH,KAAK2K,iBAFlB,mBASZ,yBAAKlL,UAAU,cACf,yBAAKA,UAAU,eACX,yBAAKA,UAAU,oBACf,uBAAGA,UAAU,WACT,uBAAGA,UAAU,sBAAsB2L,sBAAoB,UAAUC,qBAAmB,QAAQC,qBAAmB,mBAAmBC,OAAO,SAASV,KAAK,yIACvJ,yCAKJ,uBAAGpL,UAAU,WACT,0BAAMA,UAAU,oBAAoBU,QAASH,KAAK+J,kBAAlD,uB,GA7LXtJ,cAiNNC,eANS,SAAC7C,GACrB,MAAO,CACHL,WAAYK,EAAML,WAAWA,cAIG,CACpCD,aAAcA,EACdgN,gBf5J2B,SAACiB,GAAD,OAAe,SAAA/N,GAC1CA,EAAS,CACLC,KC7DmB,cD8DnBC,QAAS6N,OeuJF9K,CAGZoJ,GC9MY2B,MATf,WACE,OACE,yBAAKhM,UAAU,OACb,kBAAC,EAAD,MACA,kBAAC,EAAD,Q,uBCPAiM,EAAe,CACjBlO,WAAY,wBAiBDmO,EAda,WAAmC,IAAlC9N,EAAiC,uDAAzB6N,EAAcvE,EAAW,uCAC1D,MhBPyB,kBgBOtBA,EAAOzJ,KACC,eACAG,EADP,CAEIL,WAAY2J,EAAOxJ,UAIhB,eACAE,ICZX6N,EAAe,CACfpD,aAAc,GACdC,WAAY,GACZ9J,kBAAkB,EAClBG,gBAAgB,GAkCLgN,EA/BW,WAAiC,IAAhC/N,EAA+B,uDAAzB6N,EAAcvE,EAAW,uCACtD,MjBV6B,sBiBU1BA,EAAOzJ,KACC,eACAG,EADP,CAEIyK,aAAcnB,EAAOxJ,QACrBc,kBAAkB,IjBbC,oBiBgBlB0I,EAAOzJ,KACL,eACAG,EADP,CAEI0K,WAAYpB,EAAOxJ,QACnBiB,gBAAgB,IjBnBQ,yBiBsBvBuI,EAAOzJ,KACL,eACAG,EADP,CAEIyK,aAAc,GACdC,WAAY,GACZ9J,kBAAkB,EAClBG,gBAAgB,IAIb,eACAf,ICjCX6N,EAAe,CACfjD,aAAc9B,GAiBHkF,EAdW,WAAiC,IAAhChO,EAA+B,uDAAzB6N,EAAcvE,EAAW,uCACtD,MlBJuB,gBkBIpBA,EAAOzJ,KACC,eACAG,EADP,CAEI4K,aAActB,EAAOxJ,UAIlB,eACAE,ICXAiO,eAAgB,CAC3BtO,WAAYmO,EACZnN,cAAeoN,EACfnD,aAAcoD,ICDZE,GAAa,CAACC,KAEPC,GAAQC,YACjBC,GAJiB,GAQjBC,YACIC,IAAe,WAAf,EAAmBN,IACnB5C,OAAOmD,8BAAgCnD,OAAOmD,iCCRtDC,IAASC,OACL,kBAAC,IAAD,CAAUP,MAAOA,IACb,kBAAC,EAAD,OAEJ/M,SAASC,eAAe,U,mBCX5BsN,EAAOC,QAAU,CAAC,SAAW,yB","file":"static/js/main.fcb14262.chunk.js","sourcesContent":["export const selectStartNode = \"fa fa-play node-icon\";\nexport const selectEndNode = \"fa fa-stop node-icon\";\nexport const selectTraffic = \"fa fa-car node-icon\";\nexport const selectWall = \"fa fa-ban node-icon\";\nexport const testAction = \"testing\";","import {\n    SELECT_ACTION,\n    SELECT_START_GRID,\n    SELECT_END_GRID,\n    RESET_SELECTED_GRIDS,\n    SELECT_ALGO,\n    IS_HOVER\n} from './types';\n\nimport { \n    selectStartNode, \n    selectEndNode,\n    selectTraffic\n} from '../userActions/userActions'; //This is related to the user's actions\nimport { bool } from 'prop-types';\n\n//select the type of action that the user wants\nexport const selectAction = (userAction) => dispatch => {\n    //If there is something in the user action, then pass it on\n    if(userAction){\n      dispatch({\n          type: SELECT_ACTION,\n          payload: userAction\n      });  \n    }\n}  \n\n//action used to select starting or end grid\nexport const selectGrid = (selectGridData) => dispatch => {\n    /*  \n\n        {\n            userAction: \n            selectedGrid: //This is either the starting or end grid,\n            isSelected: boolean\n        }\n\n    */\n\n    if(selectGridData.userAction === selectStartNode){\n        dispatch({\n            type: SELECT_START_GRID,\n            payload: selectGridData.selectedGrid\n        });\n    }\n    else if (selectGridData.userAction === selectEndNode){\n        dispatch({\n            type: SELECT_END_GRID,\n            payload: selectGridData.selectedGrid\n        });\n    }\n\n\n}\n\n//action used to reset selected starting and ending grids\nexport const resetSelectedGrids = () => dispatch => {\n    dispatch({\n        type: RESET_SELECTED_GRIDS\n    })\n}\n\n//action used to select Algorithm\nexport const selectAlgorithm = (algorithm) => dispatch => {\n    dispatch({\n        type: SELECT_ALGO,\n        payload: algorithm\n    })\n}\n\n//Action is used to trigger and determine if a current node is being hovered over by the mouse or not being hovered over by the mouse\n//This action does not work and hence should be depleted\nexport const isHoverAction = (boolValue) => dispatch => {\n    dispatch({\n        type: IS_HOVER,\n        payload: boolValue\n    })\n}","export const SELECT_ACTION = \"SELECT_ACTION\";\nexport const SELECT_START_GRID = \"SELECT_START_GRID\";\nexport const SELECT_END_GRID = \"SELECT_END_GRID\";\nexport const RESET_SELECTED_GRIDS = \"RESET_SELECTED_GRIDS\";\nexport const SELECT_ALGO = \"SELECT_ALGO\";\nexport const IS_HOVER = \"IS_HOVER\";","import React, {Component} from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\n\nimport { selectGrid, selectAction } from '../../actions/index';\nimport { selectStartNode, selectEndNode, selectTraffic, testAction, selectWall } from '../../userActions/userActions';\nimport \"./Node.css\";\n\nclass Node extends Component {\n\n    state = {\n        iconName: \"\",\n        isHovered: false\n    }\n\n    //This is just a test\n    clickButton = () => {\n        //let message = \"Row: \" + this.props.row + \" Column: \" + this.props.column + \" isVisited: \" + this.props.isVisited;\n\n        console.log(this.props); //Leaving this for now for testing\n\n        let selectGridData = {\n            userAction: this.props.userAction,\n            selectedGrid: {\n                row: this.props.row,\n                column: this.props.column\n            }\n        }\n\n        if(this.props.userAction === selectStartNode){\n            if(this.props.selectedGrids.startingSelected !== true){\n                this.props.selectGrid(selectGridData);\n                this.props.updateState(this.props.row, this.props.column, this.props.userAction);\n                this.props.selectAction(selectEndNode);\n            }\n        }\n        else if(this.props.userAction === selectEndNode){\n            if(this.props.selectedGrids.endingSelected !== true){\n                this.props.selectGrid(selectGridData);\n                this.props.updateState(this.props.row, this.props.column, this.props.userAction);\n                this.props.selectAction(selectStartNode); //switch action to select end node\n            }\n        }\n        /* else if(this.props.userAction === selectTraffic){\n            this.props.updateState(this.props.row, this.props.column, this.props.userAction);\n        } */\n        else if(this.props.userAction === testAction){\n            //alert(\"you clicked on me\");\n            console.log(this.props.distance);\n            console.log(\"Prev Node: \", this.props.prevNode);\n\n        }\n        //console.log(this.props.isWall);\n\n    }\n\n    //check out the event listener on mousemove or onmouseenter\n    mouseDownEvent = (e) => {\n\n        this.setState({isHovered: true}); //Set isHovered to true\n        //Set focus to be on the current element that the user is hovering on top of with their mouse\n        document.getElementById(`nodeParent-${this.props.row}-${this.props.column}`).focus();\n\n        //Set the hovered over node icon to whatever the current action is\n        if(this.props.isWall === false && this.props.isStart === false && this.props.isEnd === false && this.props.isWeight === false){\n            document.getElementById(`icon-${this.props.row}-${this.props.column}`).className = this.props.userAction;\n        }\n    }\n\n    mouseOutEvent = (e) => {\n        this.setState({isHovered: false});\n\n        //Remove the node icon if you're not hovering over a node icon\n        if(this.props.isWall === false && this.props.isStart === false && this.props.isEnd === false && this.props.isWeight === false){\n            document.getElementById(`icon-${this.props.row}-${this.props.column}`).className = \"\";\n        }\n\n    }\n\n    pressDownKey = (e) => {\n        //e.preventDefault();\n        //Add traffic/weight for the user\n        if(this.state.isHovered && e.key.toLowerCase() === 'w'){\n            if(this.props.userAction === selectTraffic){\n                this.props.updateState(this.props.row, this.props.column, this.props.userAction);\n            }\n        }\n        //add wall for the user\n        else if(this.state.isHovered && e.key.toLowerCase() === 'e'){\n            if(this.props.userAction === selectWall){\n                this.props.updateState(this.props.row, this.props.column, this.props.userAction);\n                //document.getElementById(`icon-${this.props.row}-${this.props.column}`).className = \"\";\n            }\n        }\n    }\n\n    render(){\n        \n        let myStyle = {\n            background: \"\"\n        };\n\n        let iconName = \"\";\n\n        if(this.props.isPath === true){\n            myStyle.background = \"hsl(171, 100%, 41%)\";\n        }\n        if(this.props.isStart === true){\n            iconName = selectStartNode;\n        }\n        else if(this.props.isEnd === true){\n            iconName = selectEndNode;\n        }\n        else if(this.props.isWeight === true){\n            iconName = selectTraffic;\n        }\n        else if(this.props.isWall === true){\n            iconName = \"node-wall\";\n            //document.getElementById(`node-${this.props.row}-${this.props.column}`).className = \"node node-wall\";\n        }\n        \n        //Consider adding another div component within this one for css styling purposes\n        return (\n            <div \n                id={`nodeParent-${this.props.row}-${this.props.column}`}\n                className=\"node\" \n                onClick={this.clickButton}\n                onMouseEnter={this.mouseDownEvent}\n                onMouseLeave={this.mouseOutEvent}\n                onKeyDown={this.pressDownKey}\n                tabIndex=\"0\"\n                style={myStyle}\n            >\n                <div \n                    id={`node-${this.props.row}-${this.props.column}`}\n                    className=\"node\"\n                >\n                    <i\n                        id={`icon-${this.props.row}-${this.props.column}`}\n                        className={iconName}\n                    ></i>\n                </div>\n            </div>\n        )\n    }\n}\n\nNode.propTypes = {\n    row: PropTypes.number,\n    column: PropTypes.number,\n    startRow: PropTypes.number,\n    startColumn: PropTypes.number,\n    isVisted: PropTypes.bool,\n    isPath: PropTypes.bool,\n    prevNode: PropTypes.object,\n    updateState: PropTypes.func,\n    isStart: PropTypes.bool,\n    isEnd: PropTypes.bool,\n    isWall: PropTypes.bool,\n    distance: PropTypes.number,\n    isWeight: PropTypes.bool,\n    fValue: PropTypes.number\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        userAction: state.userAction.userAction,\n        selectedGrids: state.selectedGrids\n    }\n}\n\nexport default connect(mapStateToProps, {\n    selectGrid: selectGrid,\n    selectAction: selectAction\n})(Node);","import { unwatchFile } from \"fs\";\nimport { cloneWithoutLoc } from \"@babel/types\";\n\n//This is our breadth first search function\nexport function BFS(grid, startRow, startColumn, endRow, endColumn){\n\n    let counter = 0;\n    let maxRow = grid.length;\n    let maxColumn = grid[0].length;\n    let startingNode = grid[startRow][startColumn]; //this will be our starting node\n    let current;\n    let queue = [];\n    let visited = [];\n\n    //array.push -> push an element in front of an array\n    //array.shift -> remove an element in front of an array\n\n    //Set the startingNode isVisited to true\n    startingNode.isVisited = true;\n    visited.push({\n        row: startRow,\n        column: startColumn\n    });\n\n\n    queue.push(startingNode); //We're pushing our starting node into the queue\n\n    while(queue.length){ //While there is something in the queue, do something below\n\n        current = queue.shift(); //remove first node from queue and assign it to the current variable\n\n        let childrens = getChildren(current, maxRow, maxColumn);\n\n        //loop through each children and mark them as visited\n\n        for (var a = 0; a < childrens.length; a++){\n            let row = childrens[a].row;\n            let column = childrens[a].column;\n\n            if(grid[row][column].isVisited){\n                continue; //skip any node that was already visited\n            }\n\n            if(grid[row][column].isWall){\n                continue;\n            }\n\n            grid[row][column].isVisited = true;\n            visited.push({\n                row: row,\n                column: column\n            });\n\n            grid[row][column].prevNode = {\n                row: current.row,\n                column: current.column\n            }\n            \n            if(endRow === childrens[a].row && endColumn === childrens[a].column){\n\n                let shortestPath = getShortestPath(grid, grid[row][column]);\n\n                return {\n                    shortestPath: shortestPath,\n                    visited: visited\n                } //This will break the loop\n            }\n\n            queue.push(grid[row][column]);\n            \n        }\n    }\n}\n\n\n//This function will take in a node, and it will return the rows and columns of it's childrens\nconst getChildren = (node, maxRow, maxColumn) => {\n    //We're going to get the children of this node\n\n    let row = node.row;\n    let column = node.column;\n    let children = []; //Empty array //We're going to push an object into here\n\n    //grid.length gives us the number of rows\n    //grid[0].length gives us the number of columns\n\n    //add left children\n    if(column-1 >= 0){\n        children.push({\n            row: row,\n            column: column-1\n        })\n    }\n    //add right children\n    if(column+1 < maxColumn){\n        children.push({\n            row: row,\n            column: column+1\n        })\n    }\n    //add top children\n    if(row-1 >= 0){\n        children.push({\n            row: row-1,\n            column: column\n        })\n    }\n    //add bottom children\n    if(row+1 <maxRow){\n        children.push({\n            row: row+1,\n            column: column\n        })\n    }\n\n    return children; //We will return an array of children nodes here\n}\n\n//This function will return the shortest path via BFS\nconst getShortestPath = (grid, endingNode) => {\n    let current = grid[endingNode.row][endingNode.column];\n    let shortestPath = [];\n\n    shortestPath.push({\n        row: endingNode.row,\n        column: endingNode.column\n    });\n\n    while(current.prevNode !== undefined){\n\n        current = grid[current.prevNode.row][current.prevNode.column];\n\n        shortestPath.push({\n            row: current.row,\n            column: current.column\n        });\n    }\n\n    return shortestPath;\n}","//Function used to return childrens of a node\nexport function getChildrens(node, maxRow, maxColumn){\n    let row = node.row;\n    let column = node.column;\n    let children = []; //Empty array //We're going to push an object into here\n\n    //grid.length gives us the number of rows\n    //grid[0].length gives us the number of columns\n\n    //add left children\n    if(column-1 >= 0){\n        children.push({\n            row: row,\n            column: column-1\n        })\n    }\n    //add top children\n    if(row-1 >= 0){\n        children.push({\n            row: row-1,\n            column: column\n        })\n    }\n    //add right children\n    if(column+1 < maxColumn){\n        children.push({\n            row: row,\n            column: column+1\n        })\n    }\n    //add bottom children\n    if(row+1 < maxRow){\n        children.push({\n            row: row+1,\n            column: column\n        })\n    }\n\n    return children; //We will return an array of children nodes here\n}\n\n\n//Function used to return the shorted path of an algorithm\nexport const getShortestPath = (grid, endingNode) => {\n    let current = grid[endingNode.row][endingNode.column];\n    let shortestPath = [];\n\n    shortestPath.push({\n        row: endingNode.row,\n        column: endingNode.column\n    });\n\n    while(current.prevNode !== undefined){\n\n        current = grid[current.prevNode.row][current.prevNode.column];\n\n        shortestPath.push({\n            row: current.row,\n            column: current.column\n        });\n    }\n\n    return shortestPath;\n}\n\nexport function getChildrensDijkstra(grid, node) {\n    let row = node.row;\n    let column = node.column;\n    let maxRow = grid.length;\n    let maxCol = grid[0].length;\n    let childrens = [];\n\n    //add left children\n    if(column-1 >= 0){\n        \n    }\n    //add top children\n    if(row-1 >= 0){\n        \n    }\n    //add right children\n    if(column+1 < maxCol){\n        \n    }\n    //add bottom children\n    if(row+1 < maxRow){\n        \n    }\n\n    return childrens; //We will return an array of children nodes here\n}","\n\nimport { getChildrens, getShortestPath } from './Algofunctions/Algofunctions';\n\n\nexport function DFS(grid, startRow, startCol, endRow, endCol){\n\n    let maxRow = grid.length;\n    let maxCol = grid[0].length;\n    let startingNode = grid[startRow][startCol]; //This will be our starting node\n    let stack = [];\n    let visited = []; //This will be an array of objects\n    /*\n        {\n            row: rowHere,\n            column: columnHere\n        }\n    */\n\n    /*\n        Data that each node contains    \n\n        row: row,\n        column: column,\n        startRow: undefined,\n        startColumn: undefined,\n        isVisited: false,\n        isPath: false,\n        prevNode: undefined,\n        isStart: false,\n        isEnd: false,\n    */\n\n    startingNode.isVisited = true;\n    visited.push({\n        row: startRow,\n        column: startCol\n    })\n    stack.push(startingNode); //Pushes the starting node into the stack\n\n    //While there is something in our stack, execute the following code below\n    while(stack.length){\n\n        let currentNode = stack.pop(); //Remove last element of your stack and assign it to the currentNode variable\n        if(currentNode.isVisited === false){\n            currentNode.isVisited = true;\n            visited.push({\n                row: currentNode.row,\n                column: currentNode.column\n            });\n        }\n\n        if(endRow === currentNode.row && endCol === currentNode.column){\n\n            //This function does not work with DFS to find the shortest path\n            let shortestPath = getShortestPath(grid, grid[currentNode.row][currentNode.column]);\n\n            return {\n                shortestPath: shortestPath,\n                visited: visited\n            }\n        }\n\n        //Create a function to retrieve childrens\n        let childrens = getChildrens(currentNode, maxRow, maxCol);\n\n        for(var a = 0; a < childrens.length; a++){\n            let row = childrens[a].row;\n            let column = childrens[a].column;\n\n            if(grid[row][column].isVisited){\n                continue;\n            }\n            if(grid[row][column].isWall){\n                continue;\n            }\n            \n            stack.push(grid[row][column]);\n\n            grid[row][column].prevNode = {\n                row: currentNode.row,\n                column: currentNode.column\n            }\n\n        }\n    }\n}","class priorityQueue {\n    constructor(){\n        this.queue = [] //We'll push our nodes into this queue\n    }\n\n    addQueue = (node) => {\n        if(!this.queue.includes(node)){\n            //console.log(\"this is true\");\n            //Only add to the queue if the node is not already there\n            this.queue.push(node);\n        }\n        //this.queue.push(node);\n\n        //Bubble the node up based on priority, meaning distance\n        let currentIdx = this.queue.length - 1;\n        let currentNode = this.queue[currentIdx];\n\n        while(currentIdx > 0){\n            //console.log(currentIdx);\n            let parentIdx = Math.floor((currentIdx-1)/2);\n            let parent = this.queue[parentIdx];\n\n            if(currentNode.distance > parent.distance) break;\n            this.queue[parentIdx] = currentNode;\n            this.queue[currentIdx] = parent;\n\n            currentIdx = parentIdx;\n        }\n    }\n\n    //Create an addQueue function for the ATreeSearch algorithm\n    addQueueFValue = (node) => {\n        if(!this.queue.includes(node)){\n            //console.log(\"this is true\");\n            //Only add to the queue if the node is not already there\n            this.queue.push(node);\n        }\n        //this.queue.push(node);\n\n        //Bubble the node up based on priority, meaning distance\n        let currentIdx = this.queue.length - 1;\n        let currentNode = this.queue[currentIdx];\n\n        while(currentIdx > 0){\n            //console.log(currentIdx);\n            let parentIdx = Math.floor((currentIdx-1)/2);\n            let parent = this.queue[parentIdx];\n\n            if(currentNode.fValue > parent.fValue) break;\n            this.queue[parentIdx] = currentNode;\n            this.queue[currentIdx] = parent;\n\n            currentIdx = parentIdx;\n        }\n    }\n\n    deQueue = () => {\n        //console.log(\"deQueue initialized\");\n        let firstPriority = this.queue[0];\n        let lastPriority = this.queue.pop(); //This should be trickled down\n\n        if(this.queue.length > 0){\n            this.queue[0] = lastPriority;\n            this.sinkDown();\n        }\n\n        return firstPriority;\n    }\n\n    sinkDown = () => {\n        let currentIdx = 0;\n        let length = this.queue.length;\n        let currentNode = this.queue[0];\n\n        while(true){\n            //Find the current Node's childs\n            let leftidx = 2 * currentIdx + 1; //check if these are out of bounds\n            let rightidx = 2 * currentIdx + 2;\n            let left, right;\n            let swap = null;\n\n            if(leftidx < length){\n                left = this.queue[leftidx];\n                if(currentNode.distance > left.distance){\n                    swap = leftidx;\n                }\n            }\n            if(rightidx < length){\n                right = this.queue[rightidx];\n                if(\n                    (currentNode.distance > right.distance && swap === null) \n                    || \n                    (swap !== null && right.distance < left.distance )){\n                        swap = rightidx;\n                }\n            }\n\n            if(swap === null) break;\n            let childNode = this.queue[swap];\n            this.queue[currentIdx] = childNode;\n            this.queue[swap] = currentNode;\n            currentIdx = swap;\n\n        }\n    }\n\n    //deQueue for fValue\n    deQueueFValue = () => {\n        //console.log(\"deQueue initialized\");\n        let firstPriority = this.queue[0];\n        let lastPriority = this.queue.pop(); //This should be trickled down\n\n        if(this.queue.length > 0){\n            this.queue[0] = lastPriority;\n            this.sinkDownFValue();\n        }\n\n        return firstPriority;\n    }\n\n    //sinkDown for fValue\n    sinkDownFValue = () => {\n        let currentIdx = 0;\n        let length = this.queue.length;\n        let currentNode = this.queue[0];\n\n        while(true){\n            //Find the current Node's childs\n            let leftidx = 2 * currentIdx + 1; //check if these are out of bounds\n            let rightidx = 2 * currentIdx + 2;\n            let left, right;\n            let swap = null;\n\n            if(leftidx < length){\n                left = this.queue[leftidx];\n                if(currentNode.fValue > left.fValue){\n                    swap = leftidx;\n                }\n            }\n            if(rightidx < length){\n                right = this.queue[rightidx];\n                if(\n                    (currentNode.fValue > right.fValue && swap === null) \n                    || \n                    (swap !== null && right.fValue < left.fValue )){\n                        swap = rightidx;\n                }\n            }\n\n            if(swap === null) break;\n            let childNode = this.queue[swap];\n            this.queue[currentIdx] = childNode;\n            this.queue[swap] = currentNode;\n            currentIdx = swap;\n\n        }\n    }\n\n}\n\nexport default priorityQueue;","import { getChildrens, getShortestPath } from './Algofunctions/Algofunctions';\nimport priorityQueue from '../dataStructures/priorityQueue';\n\nconst Dijkstra = (grid, startRow, startColumn, endRow, endColumn) => {\n\n    let maxRow = grid.length;\n    let maxCol = grid[0].length;\n    let startingNode = grid[startRow][startColumn]; \n    let queue = new priorityQueue();\n    let visited = [];\n    startingNode.distance = 0;\n    queue.addQueue(startingNode);\n    let currentNode;\n    let childrens;\n\n    while(queue.queue.length){\n        currentNode = queue.deQueue(); //Remove first priority from your array\n        if(currentNode.isWall){continue}\n\n        childrens = getChildrens(currentNode, maxRow, maxCol);\n        if(currentNode.isVisited === false){\n            currentNode.isVisited = true;\n            visited.push({\n                row: currentNode.row,\n                column: currentNode.column\n            });\n        }\n        \n        for(var a = 0; a < childrens.length; a++){\n\n            //let prevDistance = grid[currentNode.row][currentNode.column].distance;\n            if(grid[childrens[a].row][childrens[a].column].isVisited){continue}\n            //If current child node is a wall, then skip the current node\n            if(grid[childrens[a].row][childrens[a].column].isWall){continue}\n\n            if(grid[childrens[a].row][childrens[a].column].prevNode === undefined){\n                grid[childrens[a].row][childrens[a].column].prevNode = {\n                    row: currentNode.row,\n                    column: currentNode.column\n                }\n            }\n\n            //Purpose of the code below\n            //This will compare the distance between the current node and this child's prevNode\n            //Which ever is the lowest, will be assigned as the child's previous node\n            if(grid[childrens[a].row][childrens[a].column].prevNode.row !== currentNode.row \n                && grid[childrens[a].row][childrens[a].column].prevNode.column !== currentNode.column\n            ){\n                let prevRow = grid[childrens[a].row][childrens[a].column].prevNode.row;\n                let prevColumn = grid[childrens[a].row][childrens[a].column].prevNode.column;\n                let prevNode = grid[prevRow][prevColumn];\n\n                if(prevNode.distance !== currentNode.distance){\n                    if(prevNode.distance < currentNode.distance){\n                        grid[childrens[a].row][childrens[a].column].prevNode = {\n                            row: prevRow,\n                            column: prevColumn\n                        }\n                    }\n\n                }\n                \n            }\n\n            //Add distance\n            if(grid[childrens[a].row][childrens[a].column].isWeight){\n                grid[childrens[a].row][childrens[a].column].distance = 10 + grid[grid[childrens[a].row][childrens[a].column].prevNode.row][grid[childrens[a].row][childrens[a].column].prevNode.column].distance\n            }\n            else {\n                grid[childrens[a].row][childrens[a].column].distance = 1 + grid[grid[childrens[a].row][childrens[a].column].prevNode.row][grid[childrens[a].row][childrens[a].column].prevNode.column].distance\n            }\n\n            if(currentNode.row === endRow && currentNode.column === endColumn){\n                let shortestPath = getShortestPath(grid, grid[endRow][endColumn]);\n                return {\n                    visited: visited,\n                    shortestPath: shortestPath\n                }\n            }\n\n            queue.addQueue(grid[childrens[a].row][childrens[a].column]);\n\n        }\n\n    }\n\n}\n\nexport default Dijkstra;\n","import { getChildrens, getShortestPath } from './Algofunctions/Algofunctions';\nimport priorityQueue from '../dataStructures/priorityQueue';\n\n//My priorityQurue data structure should work with this algorithm, we want to visit the node that has a \n//lower estimated distance to the end\n\nconst GreedyBestFirstSearch = (grid, startRow, startColumn, endRow, endColumn) => {\n    let queue = new priorityQueue(); //Created an instance of priorityQueue class\n\n    //For our Greedy BFS, our heuristic (an estimate measure of how far something is to an endpoint) is going to be based on Manhattan Distance\n\n    //Column = X coordinates\n    //Row = Y coordinates\n\n    let maxRow = grid.length; //used on the getChildrens algorithm\n    let maxColumn = grid[0].length; //used on the getChildrens algorithm\n    let startingNode = grid[startRow][startColumn];\n    let currentNode;\n    let visited = [];\n\n    //set starting nodes distance to 0 since we want to remove it from our queue first\n    startingNode.distance = 0;\n    queue.addQueue(startingNode);\n\n    while(queue.queue.length){\n        currentNode = queue.deQueue();\n        if(currentNode.isVisited !== true){\n            currentNode.isVisited = true;\n            visited.push({\n                row: currentNode.row,\n                column: currentNode.column\n            });\n        }\n\n        let childrens = getChildrens(currentNode, maxRow, maxColumn);\n\n        for(var a = 0; a < childrens.length; a++){\n            //loop through each of the current node's children\n            let childRow = childrens[a].row;\n            let childCol = childrens[a].column;\n            let distance = manhattanDistance(childRow, childCol, endRow, endColumn); //This is our hueristic\n\n            //Don't do anything with this node if it is a wall or already visited\n            if(grid[childRow][childCol].isWall){continue}\n            if(grid[childRow][childCol].isVisited){continue}\n\n            //assign current child's previous node\n            grid[childRow][childCol].prevNode = {\n                row: currentNode.row,\n                column: currentNode.column\n            };\n\n            //assign the current child's distance\n            if(grid[childRow][childCol].isWeight){\n                grid[childRow][childCol].distance = distance + 14;\n            }\n            else {\n                grid[childRow][childCol].distance = distance \n            }\n\n            if(currentNode.row === endRow && currentNode.column === endColumn){\n                let shortestPath = getShortestPath(grid, grid[endRow][endColumn]);\n                return {\n                    visited: visited,\n                    shortestPath: shortestPath\n                }\n            }\n\n            //add current child node into the queue after it has been assigned a previous node and distance\n            queue.addQueue(grid[childRow][childCol]);\n\n        }\n\n\n\n\n    }\n\n\n\n    \n    \n}\n\n//This is our heuristic, this function will calculate the estimate distance between a node and our selected end node\nconst manhattanDistance = (row, column, endRow, endColumn) => {\n    /*\n        (x1, x2)\n        (y1, y2)\n\n        manHattanDistance formula = | x1- y1 | + | x2 - y2 |\n\n    */\n\n    let estDistance = (Math.abs(row - endRow) + Math.abs(column - endColumn));\n\n    return estDistance;\n}\n\nexport default GreedyBestFirstSearch;","import { getChildrens, getShortestPath } from './Algofunctions/Algofunctions';\nimport priorityQueue from '../dataStructures/priorityQueue';\n\nconst ATreeSearch = (grid, startRow, startColumn, endRow, endColumn) => {\n    let maxRow = grid.length;\n    let maxCol = grid[0].length;\n    let startingNode = grid[startRow][startColumn]; \n    let queue = new priorityQueue();\n    let visited = [];\n    startingNode.distance = 0;\n    queue.addQueueFValue(startingNode);\n    let currentNode;\n    let childrens;\n\n    while(queue.queue.length){\n        currentNode = queue.deQueueFValue(); //Remove first priority from your array\n        if(currentNode.isWall){continue}\n\n        childrens = getChildrens(currentNode, maxRow, maxCol);\n        if(currentNode.isVisited === false){\n            currentNode.isVisited = true;\n            visited.push({\n                row: currentNode.row,\n                column: currentNode.column\n            });\n        }\n        \n        //We're looping through each children and assigning their distance and prevNode for them\n        for(var a = 0; a < childrens.length; a++){\n\n            let heuristic = manhattanDistance(childrens[a].row, childrens[a].column, endRow, endColumn);\n            let currentDistance;\n\n            //let prevDistance = grid[currentNode.row][currentNode.column].distance;\n            if(grid[childrens[a].row][childrens[a].column].isVisited){continue}\n            //If current child node is a wall, then skip the current node\n            if(grid[childrens[a].row][childrens[a].column].isWall){continue}\n\n            if(grid[childrens[a].row][childrens[a].column].prevNode === undefined){\n                grid[childrens[a].row][childrens[a].column].prevNode = {\n                    row: currentNode.row,\n                    column: currentNode.column\n                }\n            }\n\n            //Purpose of the code below\n            //This will compare the distance between the current node and this child's prevNode\n            //Which ever is the lowest, will be assigned as the child's previous node\n            if(grid[childrens[a].row][childrens[a].column].prevNode.row !== currentNode.row \n                && grid[childrens[a].row][childrens[a].column].prevNode.column !== currentNode.column\n            ){\n                let prevRow = grid[childrens[a].row][childrens[a].column].prevNode.row;\n                let prevColumn = grid[childrens[a].row][childrens[a].column].prevNode.column;\n                let prevNode = grid[prevRow][prevColumn];\n\n                if(prevNode.distance !== currentNode.distance){\n                    if(prevNode.distance < currentNode.distance){\n                        grid[childrens[a].row][childrens[a].column].prevNode = {\n                            row: prevRow,\n                            column: prevColumn\n                        }\n                    }\n\n                }\n                \n            }\n\n            //Add distance\n            if(grid[childrens[a].row][childrens[a].column].isWeight){\n                //We're taking the current child's prevNode's distance and adding it to the current child's distance\n                currentDistance = 10 + grid[grid[childrens[a].row][childrens[a].column].prevNode.row][grid[childrens[a].row][childrens[a].column].prevNode.column].distance;\n                grid[childrens[a].row][childrens[a].column].distance = currentDistance;\n                grid[childrens[a].row][childrens[a].column].fValue = currentDistance + heuristic;\n            }\n            else {\n                currentDistance = 1 + grid[grid[childrens[a].row][childrens[a].column].prevNode.row][grid[childrens[a].row][childrens[a].column].prevNode.column].distance;\n                grid[childrens[a].row][childrens[a].column].distance = currentDistance;\n                grid[childrens[a].row][childrens[a].column].fValue = currentDistance + heuristic;\n            }\n\n            if(currentNode.row === endRow && currentNode.column === endColumn){\n                let shortestPath = getShortestPath(grid, grid[endRow][endColumn]);\n                return {\n                    visited: visited,\n                    shortestPath: shortestPath\n                }\n            }\n\n            queue.addQueueFValue(grid[childrens[a].row][childrens[a].column]);\n\n        } //For loop\n\n    }\n}\n\n//This is our heuristic, this function will calculate the estimate distance between a node and our selected end node\nconst manhattanDistance = (row, column, endRow, endColumn) => {\n    /*\n        (x1, x2)\n        (y1, y2)\n\n        manHattanDistance formula = | x1- y1 | + | x2 - y2 |\n\n    */\n\n    let estDistance = (Math.abs(row - endRow) + Math.abs(column - endColumn));\n\n    return estDistance;\n}\n\nexport default ATreeSearch;","const setOuterWalls = (grid, width, height) => {\n    //This is going to be our helper function, we will create a recursive function, that will add walls into the array below\n    let mazeWalls = []; //Set this as an empty array for now\n\n    //First of wall, execute a function that will loop through all the outer edges of your current graph and display them as walls\n    //push columns\n    for (var a = 0; a < width; a ++){\n        //This code works\n        mazeWalls.push({\n            row: 0,\n            column: a\n        });\n        mazeWalls.push({\n            row: height-1,\n            column: a\n        });\n    }\n\n    //push rows\n    for (var b = 1; b < height; b++){\n        mazeWalls.push({\n            row: b,\n            column: 0\n        });\n        mazeWalls.push({\n            row: b,\n            column: width-1\n        })\n    }\n\n    return mazeWalls;\n}\n\nexport default setOuterWalls;","\nconst recursiveDivision = (grid, minWidth, maxWidth, minHeight, maxHeight) => {\n    //orientation determines whether we want to divide our graph horizantally or vertically first\n    //width === columns\n    //height === rows\n\n    let mazeWalls = [];\n    let vertical = \"vertical\";\n    let horizantal = \"horizontal\";\n    let orientation;\n    let fieldWidth = (maxWidth - minWidth)+3;\n    let fieldHeight = (maxHeight - minHeight)+3;\n\n    //Assign orientation\n    //if width is greater than height, we bisect vertically\n    if(fieldWidth > fieldHeight){\n        orientation = vertical;\n    }\n    else if(fieldWidth < fieldHeight){\n        orientation = horizantal;\n    }\n    else {\n        orientation = horizantal;\n    }\n    //console.log(orientation);\n\n    //base case for recursive function\n    //We may need to fix this later\n    if(fieldWidth <=2 || fieldHeight <=2){\n        return mazeWalls;\n    }\n\n    if(orientation === vertical){\n        let selectableColumns = []; //the list of columns that we can choose and select to be a wall\n        let openingRows = []; //List of rows that we're allowed to select to be an opening\n        let randomColumnIdx;\n        let randomRowIdx;\n        let selectedColumn;\n        let selectedOpeningRow;\n        console.log(\"_____\");\n        console.log(\"Vertical Code\");\n        console.log(\"_____\");\n\n        //add list of selectable columns into the array\n        for(let a = minWidth; a <= maxWidth; a+=2){\n            selectableColumns.push(a);\n        }\n\n        //add list of selectable opening rows into the array\n        for(let b = minHeight-1; b <= maxHeight+1; b+=2){\n            openingRows.push(b);\n        }\n\n        randomColumnIdx = Math.floor(Math.random() * selectableColumns.length);\n        randomRowIdx = Math.floor(Math.random() * openingRows.length);\n\n        selectedColumn = selectableColumns[randomColumnIdx];\n        selectedOpeningRow = openingRows[randomRowIdx];\n\n        let trueMinHeight = minHeight - 1; //Subtract by one to get our actual minHeight\n        let trueMaxHeight = maxHeight + 1;\n\n        for(let a = trueMinHeight; a <= trueMaxHeight; a++){\n            if(a === selectedOpeningRow){continue}\n            mazeWalls.push({\n                row: a,\n                column: selectedColumn\n            });\n            grid[a][selectedColumn].isWall = true;\n            \n        }\n\n        console.log(\"____\");\n        console.log(\"Division\");\n\n        console.log(\"minWidth: \" + minWidth);\n        console.log(\"maxWidth: \" + (selectedColumn + 2) );\n        console.log(\"minHeight: \" + minHeight);\n        console.log(\"minHeight: \" + maxHeight);\n\n        console.log(\"____\");\n        console.log(\"minWidth: \" + (selectedColumn + 2) );\n        console.log(\"maxWidth: \" + maxWidth );\n        console.log(\"minHeight: \" + minHeight);\n        console.log(\"minHeight: \" + maxHeight);\n\n        mazeWalls = mazeWalls.concat(recursiveDivision(grid, minWidth, selectedColumn-2, minHeight, maxHeight));\n        mazeWalls = mazeWalls.concat(recursiveDivision(grid, selectedColumn+2, maxWidth, minHeight, maxHeight));\n        \n\n\n    }\n    else if(orientation === horizantal){\n        let selectableRows = [];\n        let openingColumn = [];\n        let randRowIdx;\n        let randColumnIdx;\n        let selectedRow;\n        let selectedOpeningColumn;\n\n        for(let a = minHeight; a <=maxHeight; a+=2){\n            selectableRows.push(a);\n        }\n\n        for(let b = minWidth-1; b <= maxWidth+1; b+=2){\n            openingColumn.push(b);\n        }\n\n        randRowIdx = Math.floor(Math.random() * selectableRows.length);\n        randColumnIdx = Math.floor(Math.random() * openingColumn.length);\n\n        selectedRow = selectableRows[randRowIdx];\n        selectedOpeningColumn = openingColumn[randColumnIdx];\n\n        let trueMinWidth = minWidth - 1;\n        let trueMaxWidth = maxWidth + 1;\n\n        console.log(selectedOpeningColumn);\n\n        for(let a = trueMinWidth; a <= trueMaxWidth; a++){\n            if(a === selectedOpeningColumn){continue}\n            grid[selectedRow][a].isWall = true;\n            mazeWalls.push({\n                row: selectedRow,\n                column: a\n            });\n        }\n        console.log(\"selected row: \" + selectedRow);\n\n        console.log(\"____\");\n        console.log(\"Division\");\n\n        console.log(\"minWidth: \" + minWidth);\n        console.log(\"maxWidth: \" + maxWidth);\n        console.log(\"minHeight: \" + minHeight);\n        console.log(\"maxHeight: \" + (selectedRow+2));\n        console.log(\"_______\");\n\n        console.log(\"minWidth: \" + minWidth);\n        console.log(\"maxWidth: \" + maxWidth);\n        console.log(\"minHeight: \" + (selectedRow+2));\n        console.log(\"maxHeight: \" + maxHeight);\n\n        mazeWalls = mazeWalls.concat(recursiveDivision(grid, minWidth, maxWidth, minHeight, selectedRow-2));\n        mazeWalls = mazeWalls.concat(recursiveDivision(grid, minWidth, maxWidth, selectedRow+2, maxHeight));\n        \n\n    }\n    \n    return mazeWalls;\n\n}\n\nexport default recursiveDivision;","export const BreadthFS = \"Breadth-First-Search\";\nexport const DebthFS = \"Debth-First-Search\";\nexport const DijkstraAlgo = \"Dijkstra's Algorithm\";\nexport const GreedyBFS = \"Greedy Best-First-Search\";\nexport const ATreeSearchAlgo = \"A* Search Algorithm\";","/*\n    Purpose of this function. It will take in an array and object. If the object is already within the array\n    then output it as true and stop the function.\n*/\nconst ifContainsObject = (arrayObjects, objectVal) => {\n    var ifContains = false;\n\n    /*\n\n        object should contain the following\n\n        object = {\n            row: row,\n            column: column\n        }\n\n    */\n\n    for(var a = 0; a < arrayObjects.length; a++){\n        if(arrayObjects[a].row === objectVal.row \n        && arrayObjects[a].column === objectVal.column){\n            ifContains = true;\n        }\n    }\n\n    //return true if array contains the object\n    return ifContains;\n\n}\n\nexport default ifContainsObject;","import React, {Component} from 'react';\nimport { connect } from 'react-redux';\nimport Styles from './Grid.module.css';\nimport Node from \"../Node/Node\";\nimport { BFS } from \"../../Algorithms/BreadthFirstSearch\";\nimport { DFS } from \"../../Algorithms/DebthFirstSearch\";\nimport Dijkstra from \"../../Algorithms/Dijkstra\";\nimport GreedyBestFirstSearch from \"../../Algorithms/GreedyBestFirstSearch\";\nimport ATreeSearch from \"../../Algorithms/ATreeSearch\";\nimport setOuterWalls from \"../../MazeAlgorithms/setOuterWalls\";\nimport recursiveDivision from \"../../MazeAlgorithms/recursiveDivision\";\nimport { selectStartNode, selectEndNode, selectTraffic, selectWall } from '../../userActions/userActions';\nimport { BreadthFS, DebthFS, DijkstraAlgo, GreedyBFS, ATreeSearchAlgo } from '../../userAlgo/userAlgo';\nimport { selectAction, resetSelectedGrids } from '../../actions/index';\nimport ifContainsObject from '../../functions/ifContainsObject';\nimport { func } from 'prop-types';\nimport { writeFile } from 'fs';\n\nclass Grid extends Component {\n    \n    state = {\n        grid: [],\n        startRow: null,\n        startColumn: null,\n        endRow: null,\n        endColumn: null,\n        action: undefined,\n        shortestPath: [], //We probably don't need this anymore\n        visited: [],\n        traffic: [],\n        walls: [],\n\n    }\n\n    componentWillMount = () => {\n        let grid = this.createInitialGrid();\n        this.setState({grid})\n    }\n\n    addTraffic = (row, column) => {\n        let traffic = this.state.traffic;\n        let walls = this.state.walls;\n        let selectedNode = {\n            row: row,\n            column: column\n        }\n\n        if(ifContainsObject(traffic, selectedNode) === false){\n            //if the traffic array doesn't contain the your object, add it into the object\n            //For this reason, this won't allow us to add multiple of the same objects\n\n            traffic.push(selectedNode);\n            // this.setState({traffic: traffic}); //Looks like this is not needed?\n        }\n\n        if(ifContainsObject(walls, selectedNode) === true){\n            /*\n                New example of how to filter an array\n                \n                let newArray = testArray.filter(function (el) {\n                    return el.row !== object1.row ||\n                    el.column !== object1.column\n                });\n            */\n\n            //The code below will filter out and remove the \n            let newWalls = walls.filter(function (wall){\n                return wall.row !== selectedNode.row ||\n                wall.column !== selectedNode.column\n            });\n            this.setState({walls: newWalls});\n        }\n\n\n    }\n\n    addWall = (row, column) => {\n        let traffic = this.state.traffic;\n        let walls = this.state.walls;\n        let selectedNode = {\n            row: row,\n            column: column\n        }\n\n        if(ifContainsObject(walls, selectedNode) === false){\n            walls.push(selectedNode);\n        }\n        if(ifContainsObject(traffic, selectedNode) === true){\n            let newTraffic = traffic.filter(function (trafficVal){\n                return trafficVal.row !== selectedNode.row ||\n                trafficVal.column !== selectedNode.column\n            });\n            this.setState({traffic: newTraffic});\n        }\n\n    }\n\n    //This function will be used to update the grid\n    updateState = (row, column, userAction) => {\n        let grid = this.state.grid;\n\n        //grid[row][column]\n        if(userAction === selectStartNode){\n            grid[row][column].isStart = true;\n        }\n        else if(userAction === selectEndNode){\n            grid[row][column].isEnd = true;\n        }\n        //If this action is selected, assign the current node as your weight\n        else if(userAction === selectTraffic){\n            grid[row][column].isWall = false;\n            grid[row][column].isWeight = true;\n            this.addTraffic(row, column);\n\n            //Everytime this code gets executed, we want to push it into an array\n        }\n        else if(userAction === selectWall){\n            grid[row][column].isWall = true;\n            grid[row][column].isWeight = false;\n            this.addWall(row, column);\n        }\n\n        this.setState({grid: grid});\n    }\n\n    resetGrid = () => {\n        let grid = this.createInitialGrid();\n        this.setState({grid})\n        this.setState({traffic: []})\n        this.setState({walls: []});\n        let nodes = this.state.visited;\n\n        /* for(var a =  0; a < this.state.visited.length; a++){\n            document.getElementById(`node-${nodes[a].row}-${nodes[a].column}`).className = \"node\";\n        } */\n\n        this.state.visited.forEach(node => {\n            document.getElementById(`node-${node.row}-${node.column}`).className = \"node\";\n        })\n\n        this.props.resetSelectedGrids();\n        this.props.selectAction(selectStartNode);\n        //Create an action to reset the selectGrids state\n    }\n\n    animatePath = () => {\n\n        //used to re-run algorithm\n\n        let grid = this.createInitialGrid(); //This may be inefficient. We don't always want to re-create our grid\n        let nodes = this.state.visited;\n\n        //used to re-run algorithm\n\n\n        let startRow = this.props.selectedGrids.startingGrid.row;\n        let startColumn = this.props.selectedGrids.startingGrid.column;\n        let endRow = this.props.selectedGrids.endingGrid.row;\n        let endColumn = this.props.selectedGrids.endingGrid.column;\n        let algoResult;\n        let index = 0;\n\n        //The following code below is used for when the user want's to re-run the alogrithm\n        //reset all nodes\n        for(var a =  0; a < this.state.visited.length; a++){\n            document.getElementById(`node-${nodes[a].row}-${nodes[a].column}`).className = \"node\";\n        }\n\n        if(this.props.selectedGrids.startingSelected){\n            grid[startRow][startColumn].isStart = true;\n        }\n\n        if(this.props.selectedGrids.endingSelected){\n            grid[endRow][endColumn].isEnd = true;\n        }\n\n        //If any traffic was already pre-selected, re-select them for animation.\n        if(this.state.traffic.length > 0){\n            for(var a = 0; a < this.state.traffic.length; a++){\n                grid[this.state.traffic[a].row][this.state.traffic[a].column].isWeight = true;\n            }\n        }\n\n        //If any walls was already pre-selected, re-select them for animation.\n        if(this.state.walls.length > 0){\n            for(var b = 0; b < this.state.walls.length; b++){\n                grid[this.state.walls[b].row][this.state.walls[b].column].isWall = true;\n            }\n        }\n\n        this.setState({grid});\n\n\n        //The following code is used to run our algorithms\n        if(!this.props.selectedGrids.startingGrid.row || !this.props.selectedGrids.endingGrid.row){\n            alert(\"No Starting or End Nodes were selected. Please select a start and end node.\")\n        }\n        else {\n\n            try{\n            //These codes break if the algo button is pressed twice\n\n            if(this.props.selectedAlgo.selectedAlgo === BreadthFS){\n                algoResult = BFS(this.state.grid, startRow, startColumn, endRow, endColumn);\n                //this.setState({shortestPath: algoResult.shortestPath});\n                this.setState({visited: algoResult.visited});\n            }\n            else if(this.props.selectedAlgo.selectedAlgo === DebthFS){\n                algoResult = DFS(this.state.grid, startRow, startColumn, endRow, endColumn);\n                //this.setState({shortestPath: algoResult.shortestPath});\n                this.setState({visited: algoResult.visited});\n            }\n            else if(this.props.selectedAlgo.selectedAlgo === DijkstraAlgo){\n                algoResult = Dijkstra(this.state.grid, startRow, startColumn, endRow, endColumn);\n                //this.setState({shortestPath: algoResult.shortestPath});\n                this.setState({visited: algoResult.visited});\n            }\n            else if(this.props.selectedAlgo.selectedAlgo === GreedyBFS){\n                algoResult = GreedyBestFirstSearch(this.state.grid, startRow, startColumn, endRow, endColumn);\n                //this.setState({shortestPath: algoResult.shortestPath});\n                this.setState({visited: algoResult.visited});\n            }\n            else if(this.props.selectedAlgo.selectedAlgo === ATreeSearchAlgo){\n                algoResult = ATreeSearch(this.state.grid, startRow, startColumn, endRow, endColumn);\n                this.setState({visited: algoResult.visited});\n            }\n\n            algoResult.visited.forEach(node => {\n                index +=1;\n\n                setTimeout(() => {\n\n                    document.getElementById(`node-${node.row}-${node.column}`).className = \"node node-visited\";\n\n                }, index * 7);\n            });\n\n            algoResult.shortestPath.reverse(); //to reverse the shortestPath\n\n            algoResult.shortestPath.forEach(node => {\n                index+=1;\n                setTimeout(() => {\n                    document.getElementById(`node-${node.row}-${node.column}`).className = \"node node-path\";\n                }, index * 8); //10.5\n            })\n\n            }//try\n            catch{\n                alert(\"Please reset the grid\");\n            }\n\n\n        }\n    }\n\n    testFunction = () => {\n        // let startRow = this.props.selectedGrids.startingGrid.row;\n        // let startColumn = this.props.selectedGrids.startingGrid.column;\n        // let endRow = this.props.selectedGrids.endingGrid.row;\n        // let endColumn = this.props.selectedGrids.endingGrid.column;\n\n        console.log(\"_______________\");\n        console.log(\"executed new code\");\n        console.log(\"_______________\");\n\n\n        let maxWidth = this.state.grid[0].length;\n        console.log(maxWidth);\n        console.log(\" \")\n        let maxHeight = this.state.grid.length;\n        console.log(maxHeight);\n        console.log(\" \")\n        let gridCopy = this.state.grid;\n        let testArray = setOuterWalls(this.state.grid, maxWidth, maxHeight);\n\n        testArray.forEach(test => {\n            gridCopy[test.row][test.column].isWall = true;\n        });\n\n        this.setState({grid: gridCopy});\n\n        let testArray2 = recursiveDivision(this.state.grid, 2, maxWidth-3, 2, maxHeight-3); //We want to start at our max width and max height at -3 in order for the function to work\n        //We want to start at min row and min column at 2 as well\n\n        \n        testArray = testArray.concat(testArray2);\n\n        this.setState({walls: testArray});\n\n\n    }\n\n    render(){\n\n        window.onresize = () => {\n            let grid = this.createInitialGrid();\n            this.setState({grid});\n        } \n\n        let algoButton;\n\n        if(this.props.selectedAlgo.selectedAlgo){\n            algoButton = <button className=\"button\" type=\"button\" onClick={this.animatePath}>Run {this.props.selectedAlgo.selectedAlgo}</button>\n        }\n\n        return (\n            <div className=\"grid\">\n                {algoButton}\n                <button className=\"button\" type=\"button\" onClick={this.resetGrid}>Reset Grid</button>\n                <button className=\"button\" type=\"button\" onClick={this.testFunction}>Test Button</button>\n                {\n                    this.state.grid.map((nodeRows, rowidx) => {\n                        return (\n                            <div key={rowidx} className={Styles.nodeRows}>\n                                {\n                                    \n                                    nodeRows.map((node, columnidx) => {\n                                        return <Node \n                                            key={columnidx}\n                                            row={node.row}\n                                            column={node.column}\n                                            startRow={node.startRow}\n                                            startColumn={node.startColumn}\n                                            isVisited={node.isVisited}\n                                            isPath={node.isPath}\n                                            prevNode={node.prevNode}\n                                            updateState={this.updateState}\n                                            isStart={node.isStart}\n                                            isEnd={node.isEnd}\n                                            isWall={node.isWall}\n                                            distance={node.distance}\n                                            isWeight={node.isWeight}\n                                            fValue={node.fValue}\n                                        />\n                                    })\n\n                                }\n                            </div>\n                        )\n                    })\n                }\n            </div>\n        )\n    }\n\n    //Create nodes and push them into our grid above\n    createInitialGrid = () => {\n\n        let grid = [];\n        let currentNode;\n        let width = Math.round(window.innerWidth / 25); //How do you change this as the width changes?\n        let height = 30;\n        \n        //We're going to create our grid here, and push in our node\n\n        for(var a = 0; a < height; a++){ //height\n            let nodeRows = [];\n            for(var b = 0; b < width; b++){ //width\n                //create nodes here\n                currentNode = this.createNode(a, b);\n                nodeRows.push(currentNode);\n            }\n            grid.push(nodeRows);\n        }\n\n        return grid;\n        \n    }\n\n    //Create a node\n    createNode = (row, column) => {\n        //Return the following object\n        return {\n            row: row,\n            column: column,\n            startRow: undefined,\n            startColumn: undefined,\n            isVisited: false,\n            isPath: false,\n            prevNode: undefined,\n            isStart: false,\n            isEnd: false,\n            isWall: false,\n            distance: Infinity,\n            isWeight: false,\n            fValue: Infinity //Value is used for the ATreeSearch algorithm, which relies on distance from starting node + est distance from ending node\n        }\n    }\n\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        selectedGrids: state.selectedGrids,\n        selectedAlgo: state.selectedAlgo\n    }\n}\n\nexport default connect(mapStateToProps, {\n    resetSelectedGrids: resetSelectedGrids,\n    selectAction: selectAction\n})(Grid);","import React, { Component } from 'react';\nimport { connect } from 'react-redux';\n\nimport \"./NavBar.css\";\nimport { selectEndNode, selectTraffic, selectWall,  testAction } from '../../userActions/userActions';\nimport { selectAction, selectAlgorithm } from '../../actions/index';\nimport { BreadthFS, DebthFS, DijkstraAlgo, GreedyBFS, ATreeSearchAlgo } from '../../userAlgo/userAlgo';\n\nclass NavBar extends Component {\n    /*\n\n        example of initializing state with constructor(props)\n\n        constructor(props) {\n        super(props);\n        // Don't call this.setState() here!\n        this.state = { counter: 0 };\n        this.handleClick = this.handleClick.bind(this);\n        }\n\n    */\n\n    constructor(props) {\n        super(props);\n    }\n\n    selectUserAction = () => {\n\n        console.log(this.startAction.innerHTML);\n\n        let node = this.startAction;\n\n    }\n\n    selectStartAction = () => {\n        //let node = this.startAction;\n        this.props.selectAction(\"fa fa-play node-icon\"); //replace this with the selectStartNode user action\n    }\n\n    selectEndAction = () => {\n        this.props.selectAction(selectEndNode);\n    }\n\n    selectTrafficAction = () => {\n        this.props.selectAction(selectTraffic);\n    }\n\n    selectWallAction = () =>{\n        this.props.selectAction(selectWall);\n    }\n\n    selectBFSAlgo = () => {\n        this.props.selectAlgorithm(BreadthFS);\n    }\n\n    selectDFSAlgo = () => {\n        this.props.selectAlgorithm(DebthFS);\n    }\n\n    selectDijkstraAlgo = () => {\n        this.props.selectAlgorithm(DijkstraAlgo);\n    }\n\n    selectGreedyBFS = () => {\n        this.props.selectAlgorithm(GreedyBFS);\n    }\n\n    selectATreeAlgo = () => {\n        this.props.selectAlgorithm(ATreeSearchAlgo);\n    }\n\n    selectTest = () => {\n        this.props.selectAction(testAction);\n    }\n\n    render(){\n        \n        return (\n            <div className=\"NavBar\">\n\n                <nav className=\"navbar is-transparent\">\n                    <div className=\"navbar-brand\">\n                        <a className=\"navbar-item\" href=\"https://bulma.io\">\n                            <img src=\"https://bulma.io/images/bulma-logo.png\" alt=\"Bulma: a modern CSS framework based on Flexbox\" width=\"112\" height=\"28\" />\n                        </a>\n                        <div className=\"navbar-burger burger\" data-target=\"navbarExampleTransparentExample\">\n                            <span></span>\n                            <span></span>\n                            <span></span>\n                        </div>\n                    </div>\n\n                    <div id=\"navbarExampleTransparentExample\" className=\"navbar-menu\">\n                        <div className=\"navbar-start\">\n                            <a className=\"navbar-item\" href=\"https://bulma.io/\">\n                                Home\n                            </a>\n                            <div className=\"navbar-item has-dropdown is-hoverable\">\n\n                                <a className=\"navbar-link\" >\n\n                                    Action\n                                </a>\n                                <div className=\"navbar-dropdown is-boxed\">\n                                    <div ref={(input) => {\n                                        this.startAction = input\n                                        }} \n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectStartAction}\n                                    >\n                                        <i className=\"fa fa-play node-icon-nav\"></i>\n                                        Start\n                                    </div>\n\n                                    <div ref={(input) => {\n                                        this.endAction = input\n                                        }} \n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectEndAction}\n\n                                    >\n                                        <i className=\"fa fa-stop node-icon-nav\"></i>\n                                        End\n                                    </div>\n\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectTrafficAction}\n                                    >\n                                        <i className=\"fa fa-car node-icon-nav\"></i>\n                                        Traffic\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectWallAction}\n                                    >\n                                        <i className=\"fa fa-ban node-icon-nav\"></i>\n                                        Wall\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectTest}\n                                    >\n                                        <i className=\"fa fa-car node-icon-nav\"></i>\n                                        Test Action\n                                    </div>\n                                </div>\n                            </div>\n                            <div className=\"navbar-item has-dropdown is-hoverable\">\n                                <a className=\"navbar-link\" >\n                                    Algorithm\n                                </a>\n                                <div className=\"navbar-dropdown is-boxed\">\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectBFSAlgo}\n                                    >\n                                        Breadth-First-Search\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectDFSAlgo}\n                                    >\n                                        Debth-First-Search\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectDijkstraAlgo}\n                                    >\n                                        Dijkstra's Algorithm\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectGreedyBFS}\n                                    >\n                                        Greedy Best-First-Search\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectATreeAlgo}\n                                    >\n                                        A* Algorithm\n                                    </div>\n                                </div>\n                            </div>\n                        </div>\n                        <div className=\"navbar-end\">\n                        <div className=\"navbar-item\">\n                            <div className=\"field is-grouped\">\n                            <p className=\"control\">\n                                <a className=\"bd-tw-button button\" data-social-network=\"Twitter\" data-social-action=\"tweet\" data-social-target=\"https://bulma.io\" target=\"_blank\" href=\"https://twitter.com/intent/tweet?text=Bulma: a modern CSS framework based on Flexbox&amp;hashtags=bulmaio&amp;url=https://bulma.io&amp;via=jgthms\">\n                                <span>\n                                    Tweet\n                                </span>\n                                </a>\n                            </p>\n                            <p className=\"control\">\n                                <span className=\"button is-primary\" onClick={this.selectUserAction}>Download</span>\n                            </p>\n                            </div>\n                        </div>\n\n                        </div>\n                    </div>\n                </nav>\n\n            </div>\n        )\n    }\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        userAction: state.userAction.userAction\n    }\n}\n\nexport default connect(mapStateToProps, {\n    selectAction: selectAction,\n    selectAlgorithm: selectAlgorithm\n})(NavBar);","import React from 'react';\n\nimport Grid from './Components/Grid/Grid';\nimport NavBar from './Components/NavBar/NavBar';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <NavBar />\n      <Grid />\n    </div>\n  );\n}\n\nexport default App;","import { SELECT_ACTION } from '../actions/types';\n\nconst initialState = {\n    userAction: \"fa fa-play node-icon\" //For now, this will be our default action\n}\n\nconst selectActionReducer = (state = initialState, action) => {\n    if(action.type === SELECT_ACTION){\n        return {\n            ...state,\n            userAction: action.payload\n        }\n    }\n    else {\n        return {\n            ...state\n        }\n    }\n}\n\nexport default selectActionReducer;\n\n","import { SELECT_START_GRID, SELECT_END_GRID, RESET_SELECTED_GRIDS } from '../actions/types';\nimport { identifier } from '@babel/types';\n\nlet initialState = {\n    startingGrid: {},\n    endingGrid: {},\n    startingSelected: false,\n    endingSelected: false\n}\n\nconst selectGridReducer = (state=initialState, action) => {\n    if(action.type === SELECT_START_GRID){\n        return {\n            ...state,\n            startingGrid: action.payload,\n            startingSelected: true\n        }\n    }\n    else if (action.type === SELECT_END_GRID){\n        return {\n            ...state,\n            endingGrid: action.payload,\n            endingSelected: true\n        }\n    }\n    else if (action.type === RESET_SELECTED_GRIDS){\n        return {\n            ...state,\n            startingGrid: {},\n            endingGrid: {},\n            startingSelected: false,\n            endingSelected: false\n        }\n    }\n    else {\n        return {\n            ...state\n        }\n    }\n}\n\nexport default selectGridReducer;","import { SELECT_ALGO } from '../actions/types';\nimport { BreadthFS } from '../userAlgo/userAlgo';\n\nlet initialState = {\n    selectedAlgo: BreadthFS\n}\n\nconst selectAlgoReducer = (state=initialState, action) => {\n    if(action.type === SELECT_ALGO){\n        return {\n            ...state,\n            selectedAlgo: action.payload\n        }\n    }\n    else {\n        return {\n            ...state\n        }\n    }\n}\n\nexport default selectAlgoReducer;","import { combineReducers } from 'redux';\nimport selectActionReducer from './selectActionReducer';\nimport selectGridReducer from './selectGridReducer';\nimport selectAlgoReducer from './selectAlgoReducer';\n\nexport default combineReducers({\n    userAction: selectActionReducer,\n    selectedGrids: selectGridReducer,\n    selectedAlgo: selectAlgoReducer\n});","import { createStore, applyMiddleware, compose } from 'redux';\nimport thunk from 'redux-thunk';\n\n//import reducers here\nimport reducers from './reducers'; // <-- this will automatically pick our index.js file\n\nconst initialState = {};\nconst middleware = [thunk];\n\nexport const store = createStore(\n    reducers,\n    initialState,\n    //applyMiddleware(...middleware)\n\n    compose(\n        applyMiddleware(...middleware),\n        window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\n    )\n);\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport 'font-awesome/css/font-awesome.min.css';\n\nimport App from './App';\nimport { store } from './store';\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>, \n    document.getElementById('root')\n);\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"nodeRows\":\"Grid_nodeRows__2V7w-\"};"],"sourceRoot":""}