{"version":3,"sources":["userActions/userActions.js","actions/index.js","actions/types.js","Components/Node/Node.js","Algorithms/BreadthFirstSearch.js","Algorithms/Algofunctions/Algofunctions.js","Algorithms/DebthFirstSearch.js","dataStructures/priorityQueue.js","Algorithms/Dijkstra.js","Algorithms/GreedyBestFirstSearch.js","Algorithms/ATreeSearch.js","MazeAlgorithms/setOuterWalls.js","MazeAlgorithms/recursiveDivision.js","userAlgo/userAlgo.js","functions/ifContainsObject.js","Components/Grid/Grid.js","Components/TutorialModal/ModalSections/ModalSections.js","Components/TutorialModal/ModalSections/ModalSections2.js","Components/TutorialModal/ModalSections/ModalSections3.js","Components/TutorialModal/TutorialModal.js","Components/NavBar/NavBar.js","App.js","reducers/selectActionReducer.js","reducers/selectGridReducer.js","reducers/selectAlgoReducer.js","reducers/selectMazeAlgoReducer.js","reducers/index.js","store.js","index.js","Components/Grid/Grid.module.css","Components/TutorialModal/tutorialImages/startAndEnd.png","Components/TutorialModal/tutorialImages/RunAlgo.png"],"names":["selectStartNode","selectEndNode","selectTraffic","selectWall","selectAction","userAction","dispatch","type","payload","Node","state","iconName","isHovered","clickButton","console","log","props","selectGridData","selectedGrid","row","column","selectedGrids","startingSelected","selectGrid","updateState","endingSelected","distance","prevNode","mouseDownEvent","e","setState","document","getElementById","focus","isWall","isStart","isEnd","isWeight","className","mouseOutEvent","pressDownKey","key","toLowerCase","myStyle","background","this","isPath","id","onClick","onMouseEnter","onMouseLeave","onKeyDown","tabIndex","style","Component","connect","BFS","grid","startRow","startColumn","endRow","endColumn","current","maxRow","length","maxColumn","startingNode","queue","visited","isVisited","push","shift","childrens","getChildren","a","shortestPath","getShortestPath","node","children","endingNode","undefined","getChildrens","DFS","startCol","endCol","maxCol","stack","currentNode","pop","priorityQueue","addQueue","includes","currentIdx","parentIdx","Math","floor","parent","addQueueFValue","fValue","deQueue","firstPriority","lastPriority","sinkDown","leftidx","rightidx","left","right","swap","childNode","deQueueFValue","sinkDownFValue","Dijkstra","prevRow","prevColumn","manhattanDistance","abs","GreedyBestFirstSearch","childRow","childCol","ATreeSearch","heuristic","currentDistance","setOuterWalls","width","height","mazeWalls","b","recursiveDivision","minWidth","maxWidth","minHeight","maxHeight","orientation","fieldWidth","fieldHeight","randomColumnIdx","randomRowIdx","selectedColumn","selectedOpeningRow","selectableColumns","openingRows","random","trueMaxHeight","concat","randRowIdx","randColumnIdx","selectedRow","selectedOpeningColumn","selectableRows","openingColumn","trueMaxWidth","BreadthFS","DebthFS","GreedyBFS","ifContainsObject","arrayObjects","objectVal","ifContains","NodeTest","val","Grid","action","traffic","walls","componentWillMount","createInitialGrid","addTraffic","selectedNode","newWalls","filter","wall","addWall","newTraffic","trafficVal","resetGrid","forEach","resetSelectedGrids","animatePath","algoResult","nodes","startingGrid","endingGrid","index","selectedAlgo","setTimeout","reverse","alert","animateMaze","outerWalls","selectedMazeAlgo","mazeAlgorithem","testFunction","round","window","innerWidth","nodeRows","createNode","Infinity","algoButton","mazeAlgoButton","onresize","map","rowidx","Styles","columnidx","ModalSections","ModalSections2","src","startAndEndImg","runAlgo","ModalSections3","TutorialModal","pressClose","classList","remove","pressPrev","displaySection","pressNext","n","sections","getElementsByClassName","display","aria-label","class","NavBar","openTutorial","add","selectUserAction","startAction","innerHTML","selectStartAction","selectEndAction","selectTrafficAction","selectWallAction","selectBFSAlgo","selectAlgorithm","selectDFSAlgo","selectDijkstraAlgo","selectGreedyBFS","selectATreeAlgo","selectRecursiveDiv","selectMazeAlgo","selectTest","data-target","ref","input","endAction","algorithm","App","initialState","selectActionReducer","selectGridReducer","selectAlgoReducer","selectMazeAlgoReducer","combineReducers","middleware","thunk","store","createStore","reducers","compose","applyMiddleware","__REDUX_DEVTOOLS_EXTENSION__","ReactDOM","render","module","exports"],"mappings":"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","file":"static/js/main.63f4a0d3.chunk.js","sourcesContent":["export const selectStartNode = \"fa fa-play node-icon\";\nexport const selectEndNode = \"fa fa-stop node-icon\";\nexport const selectTraffic = \"fa fa-car node-icon\";\nexport const selectWall = \"fa fa-ban node-icon\";\nexport const testAction = \"testing\";","import {\n    SELECT_ACTION,\n    SELECT_START_GRID,\n    SELECT_END_GRID,\n    RESET_SELECTED_GRIDS,\n    SELECT_ALGO,\n    SELECT_MAZE_ALGO,\n    IS_HOVER\n} from './types';\n\nimport { \n    selectStartNode, \n    selectEndNode,\n    selectTraffic\n} from '../userActions/userActions'; //This is related to the user's actions\nimport { bool } from 'prop-types';\n\n//select the type of action that the user wants\nexport const selectAction = (userAction) => dispatch => {\n    //If there is something in the user action, then pass it on\n    if(userAction){\n      dispatch({\n          type: SELECT_ACTION,\n          payload: userAction\n      });  \n    }\n}  \n\n//action used to select starting or end grid\nexport const selectGrid = (selectGridData) => dispatch => {\n    /*  \n\n        {\n            userAction: \n            selectedGrid: //This is either the starting or end grid,\n            isSelected: boolean\n        }\n\n    */\n\n    if(selectGridData.userAction === selectStartNode){\n        dispatch({\n            type: SELECT_START_GRID,\n            payload: selectGridData.selectedGrid\n        });\n    }\n    else if (selectGridData.userAction === selectEndNode){\n        dispatch({\n            type: SELECT_END_GRID,\n            payload: selectGridData.selectedGrid\n        });\n    }\n\n\n}\n\n//action used to reset selected starting and ending grids\nexport const resetSelectedGrids = () => dispatch => {\n    dispatch({\n        type: RESET_SELECTED_GRIDS\n    })\n}\n\n//action used to select Algorithm\nexport const selectAlgorithm = (algorithm) => dispatch => {\n    dispatch({\n        type: SELECT_ALGO,\n        payload: algorithm\n    })\n}\n\n//Action is used to trigger and determine if a current node is being hovered over by the mouse or not being hovered over by the mouse\n//This action does not work and hence should be depleted\nexport const isHoverAction = (boolValue) => dispatch => {\n    dispatch({\n        type: IS_HOVER,\n        payload: boolValue\n    })\n}\n\n\n//action used to select a maze algorithm\nexport const selectMazeAlgo = (algorithm) => dispatch => {\n    dispatch({\n        type: SELECT_MAZE_ALGO,\n        payload: algorithm\n    });\n}","export const SELECT_ACTION = \"SELECT_ACTION\";\nexport const SELECT_START_GRID = \"SELECT_START_GRID\";\nexport const SELECT_END_GRID = \"SELECT_END_GRID\";\nexport const RESET_SELECTED_GRIDS = \"RESET_SELECTED_GRIDS\";\nexport const SELECT_ALGO = \"SELECT_ALGO\";\nexport const SELECT_MAZE_ALGO = \"SELECT_MAZE_ALGO\";\nexport const IS_HOVER = \"IS_HOVER\";","import React, {Component} from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\n\nimport { selectGrid, selectAction } from '../../actions/index';\nimport { selectStartNode, selectEndNode, selectTraffic, testAction, selectWall } from '../../userActions/userActions';\nimport \"./Node.css\";\n\nclass Node extends Component {\n\n    state = {\n        iconName: \"\",\n        isHovered: false\n    }\n\n    clickButton = () => {\n        console.log(this.props);\n\n        let selectGridData = {\n            userAction: this.props.userAction,\n            selectedGrid: {\n                row: this.props.row,\n                column: this.props.column\n            }\n        }\n\n        if(this.props.userAction === selectStartNode){\n            if(this.props.selectedGrids.startingSelected !== true){\n                this.props.selectGrid(selectGridData);\n                this.props.updateState(this.props.row, this.props.column, this.props.userAction);\n                this.props.selectAction(selectEndNode);\n            }\n        }\n        else if(this.props.userAction === selectEndNode){\n            if(this.props.selectedGrids.endingSelected !== true){\n                this.props.selectGrid(selectGridData);\n                this.props.updateState(this.props.row, this.props.column, this.props.userAction);\n                this.props.selectAction(selectStartNode); //switch action to select end node\n            }\n        }\n        /* else if(this.props.userAction === selectTraffic){\n            this.props.updateState(this.props.row, this.props.column, this.props.userAction);\n        } */\n        else if(this.props.userAction === testAction){\n            //alert(\"you clicked on me\");\n            console.log(this.props.distance);\n            console.log(\"Prev Node: \", this.props.prevNode);\n\n        }\n    }\n\n    //check out the event listener on mousemove or onmouseenter\n    mouseDownEvent = (e) => {\n\n        this.setState({isHovered: true}); //Set isHovered to true\n        //Set focus to be on the current element that the user is hovering on top of with their mouse\n        document.getElementById(`nodeParent-${this.props.row}-${this.props.column}`).focus();\n\n        //Set the hovered over node icon to whatever the current action is\n        if(this.props.isWall === false && this.props.isStart === false && this.props.isEnd === false && this.props.isWeight === false){\n            document.getElementById(`icon-${this.props.row}-${this.props.column}`).className = this.props.userAction;\n        }\n    }\n\n    mouseOutEvent = (e) => {\n        this.setState({isHovered: false});\n\n        //Remove the node icon if you're not hovering over a node icon\n        if(this.props.isWall === false && this.props.isStart === false && this.props.isEnd === false && this.props.isWeight === false){\n            document.getElementById(`icon-${this.props.row}-${this.props.column}`).className = \"\";\n        }\n\n    }\n\n    pressDownKey = (e) => {\n        //Add traffic/weight for the user\n        if(this.state.isHovered && e.key.toLowerCase() === 'w'){\n            if(this.props.userAction === selectTraffic){\n                this.props.updateState(this.props.row, this.props.column, this.props.userAction);\n            }\n        }\n        //add wall for the user\n        else if(this.state.isHovered && e.key.toLowerCase() === 'e'){\n            if(this.props.userAction === selectWall){\n                this.props.updateState(this.props.row, this.props.column, this.props.userAction);\n                //document.getElementById(`icon-${this.props.row}-${this.props.column}`).className = \"\";\n            }\n        }\n    }\n\n    render(){\n        \n        let myStyle = {\n            background: \"\"\n        };\n\n        let iconName = \"\";\n\n        if(this.props.isPath === true){\n            myStyle.background = \"hsl(171, 100%, 41%)\";\n        }\n        if(this.props.isStart === true){\n            iconName = selectStartNode;\n        }\n        else if(this.props.isEnd === true){\n            iconName = selectEndNode;\n        }\n        else if(this.props.isWeight === true){\n            iconName = selectTraffic;\n        }\n        else if(this.props.isWall === true){\n            iconName = \"node-wall\";\n            //document.getElementById(`node-${this.props.row}-${this.props.column}`).className = \"node node-wall\";\n        }\n        \n        //Consider adding another div component within this one for css styling purposes\n        return (\n            <div \n                id={`nodeParent-${this.props.row}-${this.props.column}`}\n                className=\"node\" \n                onClick={this.clickButton}\n                onMouseEnter={this.mouseDownEvent}\n                onMouseLeave={this.mouseOutEvent}\n                onKeyDown={this.pressDownKey}\n                tabIndex=\"0\"\n                style={myStyle}\n            >\n                <div \n                    id={`node-${this.props.row}-${this.props.column}`}\n                    className=\"node\"\n                >\n                    <i\n                        id={`icon-${this.props.row}-${this.props.column}`}\n                        className={iconName}\n                    ></i>\n                </div>\n            </div>\n        )\n    }\n}\n\nNode.propTypes = {\n    row: PropTypes.number,\n    column: PropTypes.number,\n    startRow: PropTypes.number,\n    startColumn: PropTypes.number,\n    isVisted: PropTypes.bool,\n    isPath: PropTypes.bool,\n    prevNode: PropTypes.object,\n    updateState: PropTypes.func,\n    isStart: PropTypes.bool,\n    isEnd: PropTypes.bool,\n    isWall: PropTypes.bool,\n    distance: PropTypes.number,\n    isWeight: PropTypes.bool,\n    fValue: PropTypes.number\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        userAction: state.userAction.userAction,\n        selectedGrids: state.selectedGrids\n    }\n}\n\nexport default connect(mapStateToProps, {\n    selectGrid: selectGrid,\n    selectAction: selectAction\n})(Node);","import { unwatchFile } from \"fs\";\nimport { cloneWithoutLoc } from \"@babel/types\";\n\n//This is our breadth first search function\nexport function BFS(grid, startRow, startColumn, endRow, endColumn){\n\n    let counter = 0;\n    let maxRow = grid.length;\n    let maxColumn = grid[0].length;\n    let startingNode = grid[startRow][startColumn]; //this will be our starting node\n    let current;\n    let queue = [];\n    let visited = [];\n\n    //array.push -> push an element in front of an array\n    //array.shift -> remove an element in front of an array\n\n    //Set the startingNode isVisited to true\n    startingNode.isVisited = true;\n    visited.push({\n        row: startRow,\n        column: startColumn\n    });\n\n\n    queue.push(startingNode); //We're pushing our starting node into the queue\n\n    while(queue.length){ //While there is something in the queue, do something below\n\n        current = queue.shift(); //remove first node from queue and assign it to the current variable\n\n        let childrens = getChildren(current, maxRow, maxColumn);\n\n        //loop through each children and mark them as visited\n\n        for (var a = 0; a < childrens.length; a++){\n            let row = childrens[a].row;\n            let column = childrens[a].column;\n\n            if(grid[row][column].isVisited){\n                continue; //skip any node that was already visited\n            }\n\n            if(grid[row][column].isWall){\n                continue;\n            }\n\n            grid[row][column].isVisited = true;\n            visited.push({\n                row: row,\n                column: column\n            });\n\n            grid[row][column].prevNode = {\n                row: current.row,\n                column: current.column\n            }\n            \n            if(endRow === childrens[a].row && endColumn === childrens[a].column){\n\n                let shortestPath = getShortestPath(grid, grid[row][column]);\n\n                return {\n                    shortestPath: shortestPath,\n                    visited: visited\n                } //This will break the loop\n            }\n\n            queue.push(grid[row][column]);\n            \n        }\n    }\n}\n\n\n//This function will take in a node, and it will return the rows and columns of it's childrens\nconst getChildren = (node, maxRow, maxColumn) => {\n    //We're going to get the children of this node\n\n    let row = node.row;\n    let column = node.column;\n    let children = []; //Empty array //We're going to push an object into here\n\n    //grid.length gives us the number of rows\n    //grid[0].length gives us the number of columns\n\n    //add left children\n    if(column-1 >= 0){\n        children.push({\n            row: row,\n            column: column-1\n        })\n    }\n    //add right children\n    if(column+1 < maxColumn){\n        children.push({\n            row: row,\n            column: column+1\n        })\n    }\n    //add top children\n    if(row-1 >= 0){\n        children.push({\n            row: row-1,\n            column: column\n        })\n    }\n    //add bottom children\n    if(row+1 <maxRow){\n        children.push({\n            row: row+1,\n            column: column\n        })\n    }\n\n    return children; //We will return an array of children nodes here\n}\n\n//This function will return the shortest path via BFS\nconst getShortestPath = (grid, endingNode) => {\n    let current = grid[endingNode.row][endingNode.column];\n    let shortestPath = [];\n\n    shortestPath.push({\n        row: endingNode.row,\n        column: endingNode.column\n    });\n\n    while(current.prevNode !== undefined){\n\n        current = grid[current.prevNode.row][current.prevNode.column];\n\n        shortestPath.push({\n            row: current.row,\n            column: current.column\n        });\n    }\n\n    return shortestPath;\n}","//Function used to return childrens of a node\nexport function getChildrens(node, maxRow, maxColumn){\n    let row = node.row;\n    let column = node.column;\n    let children = []; //Empty array //We're going to push an object into here\n\n    //grid.length gives us the number of rows\n    //grid[0].length gives us the number of columns\n\n    //add left children\n    if(column-1 >= 0){\n        children.push({\n            row: row,\n            column: column-1\n        })\n    }\n    //add top children\n    if(row-1 >= 0){\n        children.push({\n            row: row-1,\n            column: column\n        })\n    }\n    //add right children\n    if(column+1 < maxColumn){\n        children.push({\n            row: row,\n            column: column+1\n        })\n    }\n    //add bottom children\n    if(row+1 < maxRow){\n        children.push({\n            row: row+1,\n            column: column\n        })\n    }\n\n    return children; //We will return an array of children nodes here\n}\n\n\n//Function used to return the shorted path of an algorithm\nexport const getShortestPath = (grid, endingNode) => {\n    let current = grid[endingNode.row][endingNode.column];\n    let shortestPath = [];\n\n    shortestPath.push({\n        row: endingNode.row,\n        column: endingNode.column\n    });\n\n    while(current.prevNode !== undefined){\n\n        current = grid[current.prevNode.row][current.prevNode.column];\n\n        shortestPath.push({\n            row: current.row,\n            column: current.column\n        });\n    }\n\n    return shortestPath;\n}\n\nexport function getChildrensDijkstra(grid, node) {\n    let row = node.row;\n    let column = node.column;\n    let maxRow = grid.length;\n    let maxCol = grid[0].length;\n    let childrens = [];\n\n    //add left children\n    if(column-1 >= 0){\n        \n    }\n    //add top children\n    if(row-1 >= 0){\n        \n    }\n    //add right children\n    if(column+1 < maxCol){\n        \n    }\n    //add bottom children\n    if(row+1 < maxRow){\n        \n    }\n\n    return childrens; //We will return an array of children nodes here\n}","\n\nimport { getChildrens, getShortestPath } from './Algofunctions/Algofunctions';\n\n\nexport function DFS(grid, startRow, startCol, endRow, endCol){\n\n    let maxRow = grid.length;\n    let maxCol = grid[0].length;\n    let startingNode = grid[startRow][startCol]; \n    let stack = [];\n    let visited = []; //This will be an array of objects\n    /*\n        {\n            row: rowHere,\n            column: columnHere\n        }\n    */\n\n    /*\n        Data that each node contains    \n\n        row: row,\n        column: column,\n        startRow: undefined,\n        startColumn: undefined,\n        isVisited: false,\n        isPath: false,\n        prevNode: undefined,\n        isStart: false,\n        isEnd: false,\n    */\n\n    startingNode.isVisited = true;\n    visited.push({\n        row: startRow,\n        column: startCol\n    })\n    stack.push(startingNode); //Pushes the starting node into the stack\n\n    //While there is something in our stack, execute the following code below\n    while(stack.length){\n\n        let currentNode = stack.pop(); //Remove last element of your stack and assign it to the currentNode variable\n        if(currentNode.isVisited === false){\n            currentNode.isVisited = true;\n            visited.push({\n                row: currentNode.row,\n                column: currentNode.column\n            });\n        }\n\n        if(endRow === currentNode.row && endCol === currentNode.column){\n\n            //This function does not work with DFS to find the shortest path\n            let shortestPath = getShortestPath(grid, grid[currentNode.row][currentNode.column]);\n\n            return {\n                shortestPath: shortestPath,\n                visited: visited\n            }\n        }\n\n        //Create a function to retrieve childrens\n        let childrens = getChildrens(currentNode, maxRow, maxCol);\n\n        for(var a = 0; a < childrens.length; a++){\n            let row = childrens[a].row;\n            let column = childrens[a].column;\n\n            if(grid[row][column].isVisited){\n                continue;\n            }\n            if(grid[row][column].isWall){\n                continue;\n            }\n            \n            stack.push(grid[row][column]);\n\n            grid[row][column].prevNode = {\n                row: currentNode.row,\n                column: currentNode.column\n            }\n\n        }\n    }\n}","class priorityQueue {\n    constructor(){\n        this.queue = [] //We'll push our nodes into this queue\n    }\n\n    addQueue = (node) => {\n        if(!this.queue.includes(node)){\n            //console.log(\"this is true\");\n            //Only add to the queue if the node is not already there\n            this.queue.push(node);\n        }\n        //this.queue.push(node);\n\n        //Bubble the node up based on priority, meaning distance\n        let currentIdx = this.queue.length - 1;\n        let currentNode = this.queue[currentIdx];\n\n        while(currentIdx > 0){\n            //console.log(currentIdx);\n            let parentIdx = Math.floor((currentIdx-1)/2);\n            let parent = this.queue[parentIdx];\n\n            if(currentNode.distance > parent.distance) break;\n            this.queue[parentIdx] = currentNode;\n            this.queue[currentIdx] = parent;\n\n            currentIdx = parentIdx;\n        }\n    }\n\n    //Create an addQueue function for the ATreeSearch algorithm\n    addQueueFValue = (node) => {\n        if(!this.queue.includes(node)){\n            //console.log(\"this is true\");\n            //Only add to the queue if the node is not already there\n            this.queue.push(node);\n        }\n        //this.queue.push(node);\n\n        //Bubble the node up based on priority, meaning distance\n        let currentIdx = this.queue.length - 1;\n        let currentNode = this.queue[currentIdx];\n\n        while(currentIdx > 0){\n            //console.log(currentIdx);\n            let parentIdx = Math.floor((currentIdx-1)/2);\n            let parent = this.queue[parentIdx];\n\n            if(currentNode.fValue > parent.fValue) break;\n            this.queue[parentIdx] = currentNode;\n            this.queue[currentIdx] = parent;\n\n            currentIdx = parentIdx;\n        }\n    }\n\n    deQueue = () => {\n        //console.log(\"deQueue initialized\");\n        let firstPriority = this.queue[0];\n        let lastPriority = this.queue.pop(); //This should be trickled down\n\n        if(this.queue.length > 0){\n            this.queue[0] = lastPriority;\n            this.sinkDown();\n        }\n\n        return firstPriority;\n    }\n\n    sinkDown = () => {\n        let currentIdx = 0;\n        let length = this.queue.length;\n        let currentNode = this.queue[0];\n\n        while(true){\n            //Find the current Node's childs\n            let leftidx = 2 * currentIdx + 1; //check if these are out of bounds\n            let rightidx = 2 * currentIdx + 2;\n            let left, right;\n            let swap = null;\n\n            if(leftidx < length){\n                left = this.queue[leftidx];\n                if(currentNode.distance > left.distance){\n                    swap = leftidx;\n                }\n            }\n            if(rightidx < length){\n                right = this.queue[rightidx];\n                if(\n                    (currentNode.distance > right.distance && swap === null) \n                    || \n                    (swap !== null && right.distance < left.distance )){\n                        swap = rightidx;\n                }\n            }\n\n            if(swap === null) break;\n            let childNode = this.queue[swap];\n            this.queue[currentIdx] = childNode;\n            this.queue[swap] = currentNode;\n            currentIdx = swap;\n\n        }\n    }\n\n    //deQueue for fValue\n    deQueueFValue = () => {\n        //console.log(\"deQueue initialized\");\n        let firstPriority = this.queue[0];\n        let lastPriority = this.queue.pop(); //This should be trickled down\n\n        if(this.queue.length > 0){\n            this.queue[0] = lastPriority;\n            this.sinkDownFValue();\n        }\n\n        return firstPriority;\n    }\n\n    //sinkDown for fValue\n    sinkDownFValue = () => {\n        let currentIdx = 0;\n        let length = this.queue.length;\n        let currentNode = this.queue[0];\n\n        while(true){\n            //Find the current Node's childs\n            let leftidx = 2 * currentIdx + 1; //check if these are out of bounds\n            let rightidx = 2 * currentIdx + 2;\n            let left, right;\n            let swap = null;\n\n            if(leftidx < length){\n                left = this.queue[leftidx];\n                if(currentNode.fValue > left.fValue){\n                    swap = leftidx;\n                }\n            }\n            if(rightidx < length){\n                right = this.queue[rightidx];\n                if(\n                    (currentNode.fValue > right.fValue && swap === null) \n                    || \n                    (swap !== null && right.fValue < left.fValue )){\n                        swap = rightidx;\n                }\n            }\n\n            if(swap === null) break;\n            let childNode = this.queue[swap];\n            this.queue[currentIdx] = childNode;\n            this.queue[swap] = currentNode;\n            currentIdx = swap;\n\n        }\n    }\n\n}\n\nexport default priorityQueue;","import { getChildrens, getShortestPath } from './Algofunctions/Algofunctions';\nimport priorityQueue from '../dataStructures/priorityQueue';\n\nconst Dijkstra = (grid, startRow, startColumn, endRow, endColumn) => {\n\n    let maxRow = grid.length;\n    let maxCol = grid[0].length;\n    let startingNode = grid[startRow][startColumn]; \n    let queue = new priorityQueue();\n    let visited = [];\n    startingNode.distance = 0;\n    queue.addQueue(startingNode);\n    let currentNode;\n    let childrens;\n\n    while(queue.queue.length){\n        currentNode = queue.deQueue(); //Remove first priority from your array\n        if(currentNode.isWall){continue} //re-add this\n\n        childrens = getChildrens(currentNode, maxRow, maxCol);\n        if(currentNode.isVisited === false){\n            currentNode.isVisited = true;\n            visited.push({\n                row: currentNode.row,\n                column: currentNode.column\n            });\n        }\n        \n        for(var a = 0; a < childrens.length; a++){\n\n            //It looks like adding the conditional statement here is resolving the issue\n            if(currentNode.row === endRow && currentNode.column === endColumn){\n                let shortestPath = getShortestPath(grid, grid[endRow][endColumn]);\n                //Error is occuring in this section of the code\n                return {\n                    visited: visited,\n                    shortestPath: shortestPath\n                }\n            }\n\n            //let prevDistance = grid[currentNode.row][currentNode.column].distance;\n            if(grid[childrens[a].row][childrens[a].column].isVisited){continue}\n            //If current child node is a wall, then skip the current node\n            if(grid[childrens[a].row][childrens[a].column].isWall){continue}\n\n\n            \n\n            if(grid[childrens[a].row][childrens[a].column].prevNode === undefined){\n                grid[childrens[a].row][childrens[a].column].prevNode = {\n                    row: currentNode.row,\n                    column: currentNode.column\n                }\n            }\n\n            //Purpose of the code below\n            //This will compare the distance between the current node and this child's prevNode\n            //Which ever is the lowest, will be assigned as the child's previous node\n            if(grid[childrens[a].row][childrens[a].column].prevNode.row !== currentNode.row \n                && grid[childrens[a].row][childrens[a].column].prevNode.column !== currentNode.column\n            ){\n                let prevRow = grid[childrens[a].row][childrens[a].column].prevNode.row;\n                let prevColumn = grid[childrens[a].row][childrens[a].column].prevNode.column;\n                let prevNode = grid[prevRow][prevColumn];\n\n                if(prevNode.distance !== currentNode.distance){\n                    if(prevNode.distance < currentNode.distance){\n                        grid[childrens[a].row][childrens[a].column].prevNode = {\n                            row: prevRow,\n                            column: prevColumn\n                        }\n                    }\n\n                }\n                \n            }\n\n            //Add distance\n            if(grid[childrens[a].row][childrens[a].column].isWeight){\n                grid[childrens[a].row][childrens[a].column].distance = 10 + grid[grid[childrens[a].row][childrens[a].column].prevNode.row][grid[childrens[a].row][childrens[a].column].prevNode.column].distance\n            }\n            else {\n                grid[childrens[a].row][childrens[a].column].distance = 1 + grid[grid[childrens[a].row][childrens[a].column].prevNode.row][grid[childrens[a].row][childrens[a].column].prevNode.column].distance\n            }\n\n            /* if(currentNode.row === endRow && currentNode.column === endColumn){\n                let shortestPath = getShortestPath(grid, grid[endRow][endColumn]);\n                //Error is occuring in this section of the code\n                return {\n                    visited: visited,\n                    shortestPath: shortestPath\n                }\n            } */\n\n            queue.addQueue(grid[childrens[a].row][childrens[a].column]);\n\n        }\n\n    }\n\n}\n\nexport default Dijkstra;\n","import { getChildrens, getShortestPath } from './Algofunctions/Algofunctions';\nimport priorityQueue from '../dataStructures/priorityQueue';\n\n//My priorityQurue data structure should work with this algorithm, we want to visit the node that has a \n//lower estimated distance to the end\n\nconst GreedyBestFirstSearch = (grid, startRow, startColumn, endRow, endColumn) => {\n    let queue = new priorityQueue();\n\n    //For our Greedy BFS, our heuristic (an estimate measure of how far something is to an endpoint) is going to be based on Manhattan Distance\n\n    //Column = X coordinates\n    //Row = Y coordinates\n\n    let maxRow = grid.length; //used on the getChildrens algorithm\n    let maxColumn = grid[0].length; //used on the getChildrens algorithm\n    let startingNode = grid[startRow][startColumn];\n    let currentNode;\n    let visited = [];\n\n    //set starting nodes distance to 0 since we want to remove it from our queue first\n    startingNode.distance = 0;\n    queue.addQueue(startingNode);\n\n    while(queue.queue.length){\n        currentNode = queue.deQueue();\n        if(currentNode.isVisited !== true){\n            currentNode.isVisited = true;\n            visited.push({\n                row: currentNode.row,\n                column: currentNode.column\n            });\n        }\n\n        let childrens = getChildrens(currentNode, maxRow, maxColumn);\n\n        for(var a = 0; a < childrens.length; a++){\n            //loop through each of the current node's children\n            let childRow = childrens[a].row;\n            let childCol = childrens[a].column;\n            let distance = manhattanDistance(childRow, childCol, endRow, endColumn); //This is our hueristic\n\n            if(currentNode.row === endRow && currentNode.column === endColumn){\n                let shortestPath = getShortestPath(grid, grid[endRow][endColumn]);\n                return {\n                    visited: visited,\n                    shortestPath: shortestPath\n                }\n            }\n\n            //Don't do anything with this node if it is a wall or already visited\n            if(grid[childRow][childCol].isWall){continue}\n            if(grid[childRow][childCol].isVisited){continue}\n\n            //assign current child's previous node\n            grid[childRow][childCol].prevNode = {\n                row: currentNode.row,\n                column: currentNode.column\n            };\n\n            //assign the current child's distance\n            if(grid[childRow][childCol].isWeight){\n                grid[childRow][childCol].distance = distance + 14;\n            }\n            else {\n                grid[childRow][childCol].distance = distance \n            }\n\n            //add current child node into the queue after it has been assigned a previous node and distance\n            queue.addQueue(grid[childRow][childCol]);\n\n        }\n    }\n}\n\n//This is our heuristic, this function will calculate the estimate distance between a node and our selected end node\nconst manhattanDistance = (row, column, endRow, endColumn) => {\n    /*\n        (x1, x2)\n        (y1, y2)\n\n        manHattanDistance formula = | x1- y1 | + | x2 - y2 |\n\n    */\n\n    let estDistance = (Math.abs(row - endRow) + Math.abs(column - endColumn));\n\n    return estDistance;\n}\n\nexport default GreedyBestFirstSearch;","import { getChildrens, getShortestPath } from './Algofunctions/Algofunctions';\nimport priorityQueue from '../dataStructures/priorityQueue';\n\nconst ATreeSearch = (grid, startRow, startColumn, endRow, endColumn) => {\n    let maxRow = grid.length;\n    let maxCol = grid[0].length;\n    let startingNode = grid[startRow][startColumn]; \n    let queue = new priorityQueue();\n    let visited = [];\n    startingNode.distance = 0;\n    queue.addQueueFValue(startingNode);\n    let currentNode;\n    let childrens;\n\n    while(queue.queue.length){\n        currentNode = queue.deQueueFValue(); //Remove first priority from your array\n        if(currentNode.isWall){continue}\n\n        childrens = getChildrens(currentNode, maxRow, maxCol);\n        if(currentNode.isVisited === false){\n            currentNode.isVisited = true;\n            visited.push({\n                row: currentNode.row,\n                column: currentNode.column\n            });\n        }\n        \n        //We're looping through each children and assigning their distance and prevNode for them\n        for(var a = 0; a < childrens.length; a++){\n\n            let heuristic = manhattanDistance(childrens[a].row, childrens[a].column, endRow, endColumn);\n            let currentDistance;\n\n            if(currentNode.row === endRow && currentNode.column === endColumn){\n                let shortestPath = getShortestPath(grid, grid[endRow][endColumn]);\n                return {\n                    visited: visited,\n                    shortestPath: shortestPath\n                }\n            }\n\n            //let prevDistance = grid[currentNode.row][currentNode.column].distance;\n            if(grid[childrens[a].row][childrens[a].column].isVisited){continue}\n            //If current child node is a wall, then skip the current node\n            if(grid[childrens[a].row][childrens[a].column].isWall){continue}\n\n            if(grid[childrens[a].row][childrens[a].column].prevNode === undefined){\n                grid[childrens[a].row][childrens[a].column].prevNode = {\n                    row: currentNode.row,\n                    column: currentNode.column\n                }\n            }\n\n            //Purpose of the code below\n            //This will compare the distance between the current node and this child's prevNode\n            //Which ever is the lowest, will be assigned as the child's previous node\n            if(grid[childrens[a].row][childrens[a].column].prevNode.row !== currentNode.row \n                && grid[childrens[a].row][childrens[a].column].prevNode.column !== currentNode.column\n            ){\n                let prevRow = grid[childrens[a].row][childrens[a].column].prevNode.row;\n                let prevColumn = grid[childrens[a].row][childrens[a].column].prevNode.column;\n                let prevNode = grid[prevRow][prevColumn];\n\n                if(prevNode.distance !== currentNode.distance){\n                    if(prevNode.distance < currentNode.distance){\n                        grid[childrens[a].row][childrens[a].column].prevNode = {\n                            row: prevRow,\n                            column: prevColumn\n                        }\n                    }\n\n                }\n                \n            }\n\n            //Add distance\n            if(grid[childrens[a].row][childrens[a].column].isWeight){\n                //We're taking the current child's prevNode's distance and adding it to the current child's distance\n                currentDistance = 10 + grid[grid[childrens[a].row][childrens[a].column].prevNode.row][grid[childrens[a].row][childrens[a].column].prevNode.column].distance;\n                grid[childrens[a].row][childrens[a].column].distance = currentDistance;\n                grid[childrens[a].row][childrens[a].column].fValue = currentDistance + heuristic;\n            }\n            else {\n                currentDistance = 1 + grid[grid[childrens[a].row][childrens[a].column].prevNode.row][grid[childrens[a].row][childrens[a].column].prevNode.column].distance;\n                grid[childrens[a].row][childrens[a].column].distance = currentDistance;\n                grid[childrens[a].row][childrens[a].column].fValue = currentDistance + heuristic;\n            }\n\n            queue.addQueueFValue(grid[childrens[a].row][childrens[a].column]);\n\n        } //For loop\n\n    }\n}\n\n//This is our heuristic, this function will calculate the estimate distance between a node and our selected end node\nconst manhattanDistance = (row, column, endRow, endColumn) => {\n    /*\n        (x1, x2)\n        (y1, y2)\n\n        manHattanDistance formula = | x1- y1 | + | x2 - y2 |\n\n    */\n\n    let estDistance = (Math.abs(row - endRow) + Math.abs(column - endColumn));\n\n    return estDistance;\n}\n\nexport default ATreeSearch;","const setOuterWalls = (grid, width, height) => {\n    //This is going to be our helper function, we will create a recursive function, that will add walls into the array below\n    let mazeWalls = []; //Set this as an empty array for now\n\n    //First of wall, execute a function that will loop through all the outer edges of your current graph and display them as walls\n    //push columns\n    for (var a = 0; a < width; a ++){\n        //This code works\n        mazeWalls.push({\n            row: 0,\n            column: a\n        });\n        mazeWalls.push({\n            row: height-1,\n            column: a\n        });\n    }\n\n    //push rows\n    for (var b = 1; b < height; b++){\n        mazeWalls.push({\n            row: b,\n            column: 0\n        });\n        mazeWalls.push({\n            row: b,\n            column: width-1\n        })\n    }\n\n    return mazeWalls;\n}\n\nexport default setOuterWalls;","\nconst recursiveDivision = (grid, minWidth, maxWidth, minHeight, maxHeight) => {\n    //orientation determines whether we want to divide our graph horizantally or vertically first\n    //width === columns\n    //height === rows\n\n    let mazeWalls = [];\n    let vertical = \"vertical\";\n    let horizantal = \"horizontal\";\n    let orientation;\n    let fieldWidth = (maxWidth - minWidth)+3;\n    let fieldHeight = (maxHeight - minHeight)+3;\n\n    //Assign orientation\n    //if width is greater than height, we disect vertically\n    if(fieldWidth > fieldHeight){\n        orientation = vertical;\n    }\n    else if(fieldWidth < fieldHeight){\n        orientation = horizantal;\n    }\n    else {\n        orientation = horizantal;\n    }\n\n    //base case for recursive function\n    if(fieldWidth <=2 || fieldHeight <=2){\n        return mazeWalls;\n    }\n\n    if(orientation === vertical){\n        let selectableColumns = []; //the list of columns that we can choose and select to be a wall\n        let openingRows = []; //List of rows that we're allowed to select to be an opening\n        let randomColumnIdx;\n        let randomRowIdx;\n        let selectedColumn;\n        let selectedOpeningRow;\n\n        //add list of selectable columns into the array\n        for(let a = minWidth; a <= maxWidth; a+=2){\n            selectableColumns.push(a);\n        }\n\n        //add list of selectable opening rows into the array\n        for(let b = minHeight-1; b <= maxHeight+1; b+=2){\n            openingRows.push(b);\n        }\n\n        randomColumnIdx = Math.floor(Math.random() * selectableColumns.length);\n        randomRowIdx = Math.floor(Math.random() * openingRows.length);\n\n        selectedColumn = selectableColumns[randomColumnIdx];\n        selectedOpeningRow = openingRows[randomRowIdx];\n\n        let trueMinHeight = minHeight - 1; //Subtract by one to get our actual minHeight\n        let trueMaxHeight = maxHeight + 1;\n\n        for(let a = trueMinHeight; a <= trueMaxHeight; a++){\n            if(a === selectedOpeningRow){continue}\n            mazeWalls.push({\n                row: a,\n                column: selectedColumn\n            });\n            //grid[a][selectedColumn].isWall = true;\n            \n        }\n\n        mazeWalls = mazeWalls.concat(recursiveDivision(grid, minWidth, selectedColumn-2, minHeight, maxHeight));\n        mazeWalls = mazeWalls.concat(recursiveDivision(grid, selectedColumn+2, maxWidth, minHeight, maxHeight));\n        \n    }\n    else if(orientation === horizantal){\n        let selectableRows = [];\n        let openingColumn = [];\n        let randRowIdx;\n        let randColumnIdx;\n        let selectedRow;\n        let selectedOpeningColumn;\n\n        for(let a = minHeight; a <=maxHeight; a+=2){\n            selectableRows.push(a);\n        }\n\n        for(let b = minWidth-1; b <= maxWidth+1; b+=2){\n            openingColumn.push(b);\n        }\n\n        randRowIdx = Math.floor(Math.random() * selectableRows.length);\n        randColumnIdx = Math.floor(Math.random() * openingColumn.length);\n\n        selectedRow = selectableRows[randRowIdx];\n        selectedOpeningColumn = openingColumn[randColumnIdx];\n\n        let trueMinWidth = minWidth - 1;\n        let trueMaxWidth = maxWidth + 1;\n\n        for(let a = trueMinWidth; a <= trueMaxWidth; a++){\n            if(a === selectedOpeningColumn){continue}\n            //grid[selectedRow][a].isWall = true;\n            mazeWalls.push({\n                row: selectedRow,\n                column: a\n            });\n        }\n\n        mazeWalls = mazeWalls.concat(recursiveDivision(grid, minWidth, maxWidth, minHeight, selectedRow-2));\n        mazeWalls = mazeWalls.concat(recursiveDivision(grid, minWidth, maxWidth, selectedRow+2, maxHeight));\n        \n    }\n    \n    return mazeWalls;\n\n}\n\nexport default recursiveDivision;","export const BreadthFS = \"Breadth-First-Search\";\nexport const DebthFS = \"Debth-First-Search\";\nexport const DijkstraAlgo = \"Dijkstra's Algorithm\";\nexport const GreedyBFS = \"Greedy Best-First-Search\";\nexport const ATreeSearchAlgo = \"A* Search Algorithm\";\nexport const RecursiveDivision = \"Recursive Division\";","/*\n    Purpose of this function. It will take in an array and object. If the object is already within the array\n    then output it as true and stop the function.\n*/\nconst ifContainsObject = (arrayObjects, objectVal) => {\n    var ifContains = false;\n\n    /*\n\n        object should contain the following\n\n        object = {\n            row: row,\n            column: column\n        }\n\n    */\n\n    for(var a = 0; a < arrayObjects.length; a++){\n        if(arrayObjects[a].row === objectVal.row \n        && arrayObjects[a].column === objectVal.column){\n            ifContains = true;\n        }\n    }\n\n    //return true if array contains the object\n    return ifContains;\n\n}\n\nexport default ifContainsObject;","import React, {Component} from 'react';\nimport { connect } from 'react-redux';\nimport Styles from './Grid.module.css';\nimport Node from \"../Node/Node\";\nimport { BFS } from \"../../Algorithms/BreadthFirstSearch\";\nimport { DFS } from \"../../Algorithms/DebthFirstSearch\";\nimport Dijkstra from \"../../Algorithms/Dijkstra\";\nimport GreedyBestFirstSearch from \"../../Algorithms/GreedyBestFirstSearch\";\nimport ATreeSearch from \"../../Algorithms/ATreeSearch\";\nimport setOuterWalls from \"../../MazeAlgorithms/setOuterWalls\";\nimport recursiveDivision from \"../../MazeAlgorithms/recursiveDivision\";\nimport { selectStartNode, selectEndNode, selectTraffic, selectWall } from '../../userActions/userActions';\nimport { BreadthFS, DebthFS, DijkstraAlgo, GreedyBFS, ATreeSearchAlgo, RecursiveDivision } from '../../userAlgo/userAlgo';\nimport { selectAction, resetSelectedGrids } from '../../actions/index';\nimport ifContainsObject from '../../functions/ifContainsObject';\nimport dataStructureTest from '../../dataStructures/dataStructureTest';\nimport { func } from 'prop-types';\nimport { writeFile } from 'fs';\n\nclass NodeTest {\n    constructor(val){\n        this.val = val;\n    }\n}\n\nclass Grid extends Component {\n    \n    state = {\n        grid: [],\n        startRow: null,\n        startColumn: null,\n        endRow: null,\n        endColumn: null,\n        action: undefined,\n        shortestPath: [], //We probably don't need this anymore\n        visited: [],\n        traffic: [],\n        walls: [],\n\n    }\n\n    componentWillMount = () => {\n        let grid = this.createInitialGrid();\n        this.setState({grid})\n    }\n\n    addTraffic = (row, column) => {\n        let traffic = this.state.traffic;\n        let walls = this.state.walls;\n        let selectedNode = {\n            row: row,\n            column: column\n        }\n\n        if(ifContainsObject(traffic, selectedNode) === false){\n            //if the traffic array doesn't contain the your object, add it into the object\n            //For this reason, this won't allow us to add multiple of the same objects\n            traffic.push(selectedNode);\n        }\n\n        if(ifContainsObject(walls, selectedNode) === true){\n            /*\n                New example of how to filter an array\n                \n                let newArray = testArray.filter(function (el) {\n                    return el.row !== object1.row ||\n                    el.column !== object1.column\n                });\n            */\n\n            //The code below will filter out and remove the \n            let newWalls = walls.filter(function (wall){\n                return wall.row !== selectedNode.row ||\n                wall.column !== selectedNode.column\n            });\n            this.setState({walls: newWalls});\n        }\n\n\n    }\n\n    addWall = (row, column) => {\n        let traffic = this.state.traffic;\n        let walls = this.state.walls;\n        let selectedNode = {\n            row: row,\n            column: column\n        }\n\n        if(ifContainsObject(walls, selectedNode) === false){\n            walls.push(selectedNode);\n        }\n        if(ifContainsObject(traffic, selectedNode) === true){\n            let newTraffic = traffic.filter(function (trafficVal){\n                return trafficVal.row !== selectedNode.row ||\n                trafficVal.column !== selectedNode.column\n            });\n            this.setState({traffic: newTraffic});\n        }\n\n    }\n\n    //This function will be used to update the grid\n    updateState = (row, column, userAction) => {\n        let grid = this.state.grid;\n\n        //grid[row][column]\n        if(userAction === selectStartNode){\n            grid[row][column].isStart = true;\n        }\n        else if(userAction === selectEndNode){\n            grid[row][column].isEnd = true;\n        }\n        //If this action is selected, assign the current node as your weight\n        else if(userAction === selectTraffic){\n            grid[row][column].isWall = false;\n            grid[row][column].isWeight = true;\n            this.addTraffic(row, column);\n\n            //Everytime this code gets executed, we want to push it into an array\n        }\n        else if(userAction === selectWall){\n            grid[row][column].isWall = true;\n            grid[row][column].isWeight = false;\n            this.addWall(row, column);\n        }\n\n        this.setState({grid: grid});\n    }\n\n    resetGrid = () => {\n        let grid = this.createInitialGrid();\n        this.setState({grid})\n        this.setState({traffic: []})\n        this.setState({walls: []});\n        let nodes = this.state.visited;\n\n        /* for(var a =  0; a < this.state.visited.length; a++){\n            document.getElementById(`node-${nodes[a].row}-${nodes[a].column}`).className = \"node\";\n        } */\n\n        this.state.visited.forEach(node => {\n            document.getElementById(`node-${node.row}-${node.column}`).className = \"node\";\n        })\n\n        this.props.resetSelectedGrids();\n        this.props.selectAction(selectStartNode);\n        //Create an action to reset the selectGrids state\n    }\n\n    animatePath = () => {\n\n        //used to re-run algorithm\n\n        let grid = this.createInitialGrid(); //This may be inefficient. We don't always want to re-create our grid\n        let nodes = this.state.visited;\n\n        //used to re-run algorithm\n\n\n        let startRow = this.props.selectedGrids.startingGrid.row;\n        let startColumn = this.props.selectedGrids.startingGrid.column;\n        let endRow = this.props.selectedGrids.endingGrid.row;\n        let endColumn = this.props.selectedGrids.endingGrid.column;\n        let algoResult;\n        let index = 0;\n\n        //The following code below is used for when the user want's to re-run the alogrithm\n        //reset all nodes\n        for(var a =  0; a < this.state.visited.length; a++){\n            document.getElementById(`node-${nodes[a].row}-${nodes[a].column}`).className = \"node\";\n        }\n\n        if(this.props.selectedGrids.startingSelected){\n            grid[startRow][startColumn].isStart = true;\n        }\n\n        if(this.props.selectedGrids.endingSelected){\n            grid[endRow][endColumn].isEnd = true;\n        }\n\n        //If any traffic was already pre-selected, re-select them for animation.\n        if(this.state.traffic.length > 0){\n            for(var a = 0; a < this.state.traffic.length; a++){\n                grid[this.state.traffic[a].row][this.state.traffic[a].column].isWeight = true;\n            }\n        }\n\n        //If any walls was already pre-selected, re-select them for animation.\n        if(this.state.walls.length > 0){\n            for(var b = 0; b < this.state.walls.length; b++){\n                grid[this.state.walls[b].row][this.state.walls[b].column].isWall = true;\n            }\n        }\n\n        this.setState({grid});\n\n        //The following code is used to run our algorithms\n        if(!this.props.selectedGrids.startingSelected || !this.props.selectedGrids.endingSelected){\n            alert(\"No Starting or End Nodes were selected. Please select a start and end node.\")\n        }\n        else {\n\n            //try{\n\n            if(this.props.selectedAlgo.selectedAlgo === BreadthFS){\n                algoResult = BFS(this.state.grid, startRow, startColumn, endRow, endColumn);\n                this.setState({visited: algoResult.visited});\n            }\n            else if(this.props.selectedAlgo.selectedAlgo === DebthFS){\n                algoResult = DFS(this.state.grid, startRow, startColumn, endRow, endColumn);\n                this.setState({visited: algoResult.visited});\n            }\n            else if(this.props.selectedAlgo.selectedAlgo === DijkstraAlgo){\n                algoResult = Dijkstra(this.state.grid, startRow, startColumn, endRow, endColumn);\n                this.setState({visited: algoResult.visited});\n            }\n            else if(this.props.selectedAlgo.selectedAlgo === GreedyBFS){\n                algoResult = GreedyBestFirstSearch(this.state.grid, startRow, startColumn, endRow, endColumn);\n                this.setState({visited: algoResult.visited});\n            }\n            else if(this.props.selectedAlgo.selectedAlgo === ATreeSearchAlgo){\n                algoResult = ATreeSearch(this.state.grid, startRow, startColumn, endRow, endColumn);\n                this.setState({visited: algoResult.visited});\n            }\n\n            algoResult.visited.forEach(node => {\n                index +=1;\n\n                setTimeout(() => {\n\n                    document.getElementById(`node-${node.row}-${node.column}`).className = \"node node-visited\";\n\n                }, index * 7);\n            });\n\n            algoResult.shortestPath.reverse(); //to reverse the shortestPath\n\n            algoResult.shortestPath.forEach(node => {\n                index+=1;\n                setTimeout(() => {\n                    document.getElementById(`node-${node.row}-${node.column}`).className = \"node node-path\";\n                }, index * 8); //10.5\n            })\n\n            //}//try\n            //catch{\n                //alert(\"Please reset the grid\");\n            //}\n\n\n        }\n    }\n\n    animateMaze = () => {\n        let maxWidth = this.state.grid[0].length;\n        let maxHeight = this.state.grid.length;\n        let gridCopy = this.state.grid;\n        let outerWalls = setOuterWalls(this.state.grid, maxWidth, maxHeight);\n        let mazeWalls;\n        let index = 0; //used for animation\n\n        if(this.props.selectedMazeAlgo.mazeAlgorithem === RecursiveDivision){\n            //Assign our walls based on the recursive division algorithm\n            mazeWalls = recursiveDivision(this.state.grid, 2, maxWidth-3, 2, maxHeight-3); //We want to start at our max width and max height at -3 in order for the function to work\n        }\n\n        outerWalls = outerWalls.concat(mazeWalls);\n\n        //used to animate the walls\n        /* outerWalls.forEach(node => {\n            index+=1;\n            setTimeout(() => {\n                document.getElementById(`icon-${node.row}-${node.column}`).className = \"node-wall\";\n            }, index * 5);\n        }) */\n\n        //Animation currently does not work at the moment because of function below\n        outerWalls.forEach(node => {\n            this.state.grid[node.row][node.column].isWall = true;\n        })\n\n        this.setState({walls: outerWalls});\n\n    }\n\n    testFunction = () => {\n        \n        let node = new NodeTest(7);\n\n        console.log(node);\n\n    }\n\n    render(){\n\n        window.onresize = () => {\n            let grid = this.createInitialGrid();\n            this.setState({grid});\n        } \n\n        let algoButton;\n        let mazeAlgoButton;\n\n        if(this.props.selectedAlgo.selectedAlgo){\n            algoButton = <button className=\"button\" type=\"button\" onClick={this.animatePath}>Run {this.props.selectedAlgo.selectedAlgo}</button>\n        }\n        if(this.props.selectedMazeAlgo.mazeAlgorithem){\n            mazeAlgoButton = <button className=\"button\" type=\"button\" onClick={this.animateMaze}>Run {this.props.selectedMazeAlgo.mazeAlgorithem}</button>\n        }\n\n\n        return (\n            <div className=\"grid\">\n                {algoButton}\n                {mazeAlgoButton}\n                <button className=\"button\" type=\"button\" onClick={this.resetGrid}>Reset Grid</button>\n                <button className=\"button\" type=\"button\" onClick={this.testFunction}>Test Button</button>\n                {\n                    this.state.grid.map((nodeRows, rowidx) => {\n                        return (\n                            <div key={rowidx} className={Styles.nodeRows}>\n                                {\n                                    \n                                    nodeRows.map((node, columnidx) => {\n                                        return <Node \n                                            key={columnidx}\n                                            row={node.row}\n                                            column={node.column}\n                                            startRow={node.startRow}\n                                            startColumn={node.startColumn}\n                                            isVisited={node.isVisited}\n                                            isPath={node.isPath}\n                                            prevNode={node.prevNode}\n                                            updateState={this.updateState}\n                                            isStart={node.isStart}\n                                            isEnd={node.isEnd}\n                                            isWall={node.isWall}\n                                            distance={node.distance}\n                                            isWeight={node.isWeight}\n                                            fValue={node.fValue}\n                                        />\n                                    })\n\n                                }\n                            </div>\n                        )\n                    })\n                }\n            </div>\n        )\n    }\n\n    //Create nodes and push them into our grid above\n    createInitialGrid = () => {\n\n        let grid = [];\n        let currentNode;\n        let width = Math.round(window.innerWidth / 25);\n        let height = 30;\n        \n        //We're going to create our grid here, and push in our node\n\n        for(var a = 0; a < height; a++){ //height\n            let nodeRows = [];\n            for(var b = 0; b < width; b++){ //width\n                //create nodes here\n                currentNode = this.createNode(a, b);\n                nodeRows.push(currentNode);\n            }\n            grid.push(nodeRows);\n        }\n\n        return grid;\n        \n    }\n\n    //Create a node\n    createNode = (row, column) => {\n        //Return the following object\n        return {\n            row: row,\n            column: column,\n            startRow: undefined,\n            startColumn: undefined,\n            isVisited: false,\n            isPath: false,\n            prevNode: undefined,\n            isStart: false,\n            isEnd: false,\n            isWall: false,\n            distance: Infinity,\n            isWeight: false,\n            fValue: Infinity //Value is used for the ATreeSearch algorithm, which relies on distance from starting node + est distance from ending node\n        }\n    }\n\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        selectedGrids: state.selectedGrids,\n        selectedAlgo: state.selectedAlgo,\n        selectedMazeAlgo: state.selectedMazeAlgo\n    }\n}\n\nexport default connect(mapStateToProps, {\n    resetSelectedGrids: resetSelectedGrids,\n    selectAction: selectAction\n})(Grid);","import React, { Component } from 'react';\nimport './ModalSections.css';\n\nclass ModalSections extends Component {\n    render(){\n        return (\n            <div className=\"sections\">\n                <div className=\"content\">\n                    <h3>Overview</h3>\n                    {/*<h2>Title</h2>*/}\n                    <p>Hi, welcome to my pathfinding visualization app that was heavily inspired by Clément Mihailescu. With this website, you have three main tabs to use below.</p>\n                    {/* Place image here */}\n                    <ul>\n                        <li>Action</li>\n                        <ul>\n                            <li>Your list of available actions to choose from. i.e. Start action is used to select a starting node.</li>\n                        </ul>\n                        <li>Algorithms</li>\n                        <ul>\n                            <li>Contains the list of available pathfinding algorithms to choose.</li>\n                        </ul>\n                        <li>Maze Algorithms</li>\n                        <ul>\n                            <li>Contains the list of available maze generation algorithms to choose.</li>\n                        </ul>\n                    </ul>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default ModalSections;","import React, { Component } from 'react';\nimport startAndEndImg from '../tutorialImages/startAndEnd.png'; //imported image\nimport runAlgo from '../tutorialImages/RunAlgo.png';\n\nclass ModalSections2 extends Component {\n    render(){\n        return (\n            <div className=\"sections hide-section\">\n                <div className=\"content\">\n                    <h3>Getting started</h3>\n                    <p> First, select and click on any square in the grid to be your starting node.\n                        Now, after selecting a starting square, your action will automatically switch to the stop action. \n                    </p>\n\n                    <p>\n                        Finally, select any square to be your end destination. You will then see a stop icon displayed on your selected square.\n                        See example of the end result below.\n                    </p>\n                    {/* Place tutorial image here */}\n                    {/* how to import an image\n                    <img \n                        className={styles.projectImage}\n                        src={state.image}\n                    />\n                    */}\n                    <img\n                        className=\"tutorialImage\"\n                        src={startAndEndImg}\n                    />\n                    <p>Finally, click on the \"Run (Algorithm Name Here)\" button to see an animation of your selected alrogrithm.</p>\n                    <img \n                        className=\"tutorialImage\"\n                        src={runAlgo}\n                    />\n\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default ModalSections2;","import React, { Component } from 'react';\n\nclass ModalSections3 extends Component {\n    render(){\n        return (\n            <div className=\"sections hide-section\">\n                <div className=\"content\">\n\n                    <h3>Selecting Walls and Wieghted Nodes (traffic)</h3>\n                    <p>Selecting walls will stop an algorithm from using nodes as a path and can encourage alternative routes. Follow the steps below to select walls.</p>\n                    <ul>\n                        <li>Select the Wall action.</li>\n                        <li>Then, hover over to any nodes and press/hold down the 'e' key. While hovering, nodes will be selected as walls.</li>\n                    </ul>\n\n                    <p>Selecting weighted nodes (traffic), will encourage weighted algorithms to avoid those nodes.\n                    Unlike walls, alrogithms can still use traffic nodes as a path but only if it leads to the shortest possible path.\n                    </p>\n\n                </div>\n\n            </div>\n        )\n    }\n}\n\nexport default ModalSections3;","import React, { Component } from 'react';\nimport './TutorialModal.css';\nimport ModalSections from './ModalSections/ModalSections';\nimport ModalSections2 from './ModalSections/ModalSections2'; //page 2\nimport ModalSections3 from './ModalSections/ModalSections3'; //page 3\n//import { thisTypeAnnotation } from '@babel/types';\n\nclass TutorialModal extends Component {\n\n    state = {\n        index: 0\n    }\n\n    pressClose = () => {\n\n        let tutModal = document.getElementById(\"tutModal\");\n        tutModal.classList.remove('is-active'); //This works\n        \n    }\n\n    pressPrev = () => {\n        this.displaySection(this.state.index += -1);\n    }\n\n    pressNext = () => {\n        this.displaySection(this.state.index += 1);\n    }\n\n    displaySection = (n) => {\n        let sections = document.getElementsByClassName(\"sections\");\n        \n        if(n < 0){\n            this.state.index = sections.length-1;\n        }\n\n        if(n > sections.length-1){\n            this.state.index = 0;\n        }\n\n        for (var a = 0; a < sections.length; a++){\n            sections[a].style.display = \"none\";\n        }\n\n        //sections[this.state.index].className = \"section\";\n        sections[this.state.index].style.display = \"block\";\n    }\n\n    render(){\n        return (\n            <div className=\"tutorialModal\">\n                <div className=\"modal\" id=\"tutModal\"> {/* create a function to deactivate this modal */}\n                    <div className=\"modal-background\"></div>\n                    <div className=\"modal-card\">\n                        <header className=\"modal-card-head\">\n                            <p className=\"modal-card-title\">Tutorial</p>\n                            <button className=\"delete\" aria-label=\"close\" onClick={this.pressClose}></button>\n                        </header>\n\n                        <section className=\"modal-card-body\">\n                            \n                            {/* Page 1 of modal */}\n                            <ModalSections />\n                            {/* Page 2 of modal */}\n                            <ModalSections2 />\n                            {/* Page 3 of modal */}\n                            <ModalSections3 />\n                        </section>\n\n                        <footer className=\"modal-card-foot\">\n                            <div className=\"field is-grouped is-grouped-right\">\n                                {/* <button className=\"button is-success\">Save changes</button>\n                                <button className=\"button\">Cancel</button> */}\n                                <button class=\"button\" onClick={this.pressPrev}>Prev</button>\n                                <button class=\"button\" onClick={this.pressNext}>Next</button>\n                            </div>\n                        </footer>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default TutorialModal;","import React, { Component } from 'react';\nimport { connect } from 'react-redux';\n\nimport \"./NavBar.css\";\nimport { selectEndNode, selectTraffic, selectWall,  testAction } from '../../userActions/userActions';\nimport { selectAction, selectAlgorithm, selectMazeAlgo } from '../../actions/index';\nimport { BreadthFS, DebthFS, DijkstraAlgo, GreedyBFS, ATreeSearchAlgo, RecursiveDivision } from '../../userAlgo/userAlgo';\nimport TutorialModal from \"../TutorialModal/TutorialModal\";\n\nclass NavBar extends Component {\n\n    constructor(props) {\n        super(props);\n    }\n\n    openTutorial = () => {\n        let tutModal = document.getElementById(\"tutModal\");\n\n        tutModal.classList.add(\"is-active\");\n\n    }\n\n    selectUserAction = () => {\n\n        console.log(this.startAction.innerHTML);\n\n        let node = this.startAction;\n\n    }\n\n    selectStartAction = () => {\n        this.props.selectAction(\"fa fa-play node-icon\"); //replace this with the selectStartNode user action\n    }\n\n    selectEndAction = () => {\n        this.props.selectAction(selectEndNode);\n    }\n\n    selectTrafficAction = () => {\n        this.props.selectAction(selectTraffic);\n    }\n\n    selectWallAction = () =>{\n        this.props.selectAction(selectWall);\n    }\n\n    selectBFSAlgo = () => {\n        this.props.selectAlgorithm(BreadthFS);\n    }\n\n    selectDFSAlgo = () => {\n        this.props.selectAlgorithm(DebthFS);\n    }\n\n    selectDijkstraAlgo = () => {\n        this.props.selectAlgorithm(DijkstraAlgo);\n    }\n\n    selectGreedyBFS = () => {\n        this.props.selectAlgorithm(GreedyBFS);\n    }\n\n    selectATreeAlgo = () => {\n        this.props.selectAlgorithm(ATreeSearchAlgo);\n    }\n\n    selectRecursiveDiv = () => {\n        this.props.selectMazeAlgo(RecursiveDivision);\n    }\n\n    selectTest = () => {\n        this.props.selectAction(testAction);\n    }\n\n    render(){\n        \n        return (\n            //I think the TutorialModal is defaulted to be hidden\n            <div className=\"NavBar\">\n                {/*<TutorialModal />*/}\n                <TutorialModal />\n\n                <nav className=\"navbar is-transparent\">\n                    <div className=\"navbar-brand\">\n                        {/*\n                        <a className=\"navbar-item\" href=\"https://bulma.io\">\n                            <img src=\"https://bulma.io/images/bulma-logo.png\" alt=\"Bulma: a modern CSS framework based on Flexbox\" width=\"112\" height=\"28\" />\n                        </a>\n                        */}\n                        <div className=\"navbar-burger burger\" data-target=\"navbarExampleTransparentExample\">\n                            <span></span>\n                            <span></span>\n                            <span></span>\n                        </div>\n                    </div>\n\n                    <div id=\"navbarExampleTransparentExample\" className=\"navbar-menu\">\n                        <div className=\"navbar-start\">\n                            {/* <a className=\"navbar-item\" href=\"https://bulma.io/\">\n                                Home\n                            </a> */}\n                            <div className=\"navbar-item has-dropdown is-hoverable\">\n\n                                <a className=\"navbar-link\" >\n\n                                    Action\n                                </a>\n                                <div className=\"navbar-dropdown is-boxed\">\n                                    <div ref={(input) => {\n                                        this.startAction = input\n                                        }} \n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectStartAction}\n                                    >\n                                        <i className=\"fa fa-play node-icon-nav\"></i>\n                                        Start\n                                    </div>\n\n                                    <div ref={(input) => {\n                                        this.endAction = input\n                                        }} \n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectEndAction}\n\n                                    >\n                                        <i className=\"fa fa-stop node-icon-nav\"></i>\n                                        End\n                                    </div>\n\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectTrafficAction}\n                                    >\n                                        <i className=\"fa fa-car node-icon-nav\"></i>\n                                        Traffic\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectWallAction}\n                                    >\n                                        <i className=\"fa fa-ban node-icon-nav\"></i>\n                                        Wall\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectTest}\n                                    >\n                                        <i className=\"fa fa-car node-icon-nav\"></i>\n                                        Test Action\n                                    </div>\n                                </div>\n                            </div>\n                            <div className=\"navbar-item has-dropdown is-hoverable\">\n                                <a className=\"navbar-link\" >\n                                    Algorithms\n                                </a>\n                                <div className=\"navbar-dropdown is-boxed\">\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectBFSAlgo}\n                                    >\n                                        Breadth-First-Search\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectDFSAlgo}\n                                    >\n                                        Debth-First-Search\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectDijkstraAlgo}\n                                    >\n                                        Dijkstra's Algorithm\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectGreedyBFS}\n                                    >\n                                        Greedy Best-First-Search\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectATreeAlgo}\n                                    >\n                                        A* Algorithm\n                                    </div>\n                                </div>\n                            </div>\n\n                            <div className=\"navbar-item has-dropdown is-hoverable\">\n                                <a className=\"navbar-link\" >\n                                    Maze Algorithms\n                                </a>\n                                <div className=\"navbar-dropdown is-boxed\">\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectRecursiveDiv}\n                                    >\n                                        Recurive Division\n                                    </div>\n                                </div>\n                            </div>\n\n                        </div>\n\n                        <div className=\"navbar-end\">\n                            <div className=\"navbar-item\">\n                                <div className=\"buttons\">\n                                    <a className=\"button is-primary\" onClick={this.openTutorial}>\n                                        <strong>Tutorial</strong>\n                                    </a>\n                                </div>\n                            </div>\n                        </div>\n\n                    </div>\n                </nav>\n\n            </div>\n        )\n    }\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        userAction: state.userAction.userAction\n    }\n}\n\nexport default connect(mapStateToProps, {\n    selectAction: selectAction,\n    selectAlgorithm: selectAlgorithm,\n    selectMazeAlgo: selectMazeAlgo\n})(NavBar);","import React from 'react';\n\nimport Grid from './Components/Grid/Grid';\nimport NavBar from './Components/NavBar/NavBar';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <NavBar />\n      <Grid />\n    </div>\n  );\n}\n\nexport default App;","import { SELECT_ACTION } from '../actions/types';\n\nconst initialState = {\n    userAction: \"fa fa-play node-icon\" //For now, this will be our default action\n}\n\nconst selectActionReducer = (state = initialState, action) => {\n    if(action.type === SELECT_ACTION){\n        return {\n            ...state,\n            userAction: action.payload\n        }\n    }\n    else {\n        return {\n            ...state\n        }\n    }\n}\n\nexport default selectActionReducer;\n\n","import { SELECT_START_GRID, SELECT_END_GRID, RESET_SELECTED_GRIDS } from '../actions/types';\nimport { identifier } from '@babel/types';\n\nlet initialState = {\n    startingGrid: {},\n    endingGrid: {},\n    startingSelected: false,\n    endingSelected: false\n}\n\nconst selectGridReducer = (state=initialState, action) => {\n    if(action.type === SELECT_START_GRID){\n        return {\n            ...state,\n            startingGrid: action.payload,\n            startingSelected: true\n        }\n    }\n    else if (action.type === SELECT_END_GRID){\n        return {\n            ...state,\n            endingGrid: action.payload,\n            endingSelected: true\n        }\n    }\n    else if (action.type === RESET_SELECTED_GRIDS){\n        return {\n            ...state,\n            startingGrid: {},\n            endingGrid: {},\n            startingSelected: false,\n            endingSelected: false\n        }\n    }\n    else {\n        return {\n            ...state\n        }\n    }\n}\n\nexport default selectGridReducer;","import { SELECT_ALGO } from '../actions/types';\nimport { BreadthFS } from '../userAlgo/userAlgo';\n\nlet initialState = {\n    selectedAlgo: BreadthFS\n}\n\nconst selectAlgoReducer = (state=initialState, action) => {\n    if(action.type === SELECT_ALGO){\n        return {\n            ...state,\n            selectedAlgo: action.payload\n        }\n    }\n    else {\n        return {\n            ...state\n        }\n    }\n}\n\nexport default selectAlgoReducer;","import { SELECT_MAZE_ALGO } from \"../actions/types\";\nimport { RecursiveDivision } from \"../userAlgo/userAlgo\";\n\nlet initialState = {\n    mazeAlgorithem: RecursiveDivision //Defaults to recursive division algorithm\n}\n\n//action.type\n//action.payload\n\nconst selectMazeAlgoReducer = (state=initialState, action) => {\n    if(action.type === SELECT_MAZE_ALGO){\n        return {\n            ...state,\n            mazeAlgorithem: action.payload\n        }\n    } else {\n        return {\n            ...state\n        }\n    }\n}\n\nexport default selectMazeAlgoReducer;","import { combineReducers } from 'redux';\nimport selectActionReducer from './selectActionReducer';\nimport selectGridReducer from './selectGridReducer';\nimport selectAlgoReducer from './selectAlgoReducer';\nimport selectMazeAlgoReducer from './selectMazeAlgoReducer';\n\nexport default combineReducers({\n    userAction: selectActionReducer,\n    selectedGrids: selectGridReducer,\n    selectedAlgo: selectAlgoReducer,\n    selectedMazeAlgo: selectMazeAlgoReducer\n});","import { createStore, applyMiddleware, compose } from 'redux';\nimport thunk from 'redux-thunk';\n\n//import reducers here\nimport reducers from './reducers'; // <-- this will automatically pick our index.js file\n\nconst initialState = {};\nconst middleware = [thunk];\n\nexport const store = createStore(\n    reducers,\n    initialState,\n    //applyMiddleware(...middleware)\n\n    compose(\n        applyMiddleware(...middleware),\n        window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\n    )\n);\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport 'font-awesome/css/font-awesome.min.css';\n\nimport App from './App';\nimport { store } from './store';\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>, \n    document.getElementById('root')\n);\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"nodeRows\":\"Grid_nodeRows__2V7w-\"};","module.exports = \"data:image/png;base64,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\"","module.exports = __webpack_public_path__ + \"static/media/RunAlgo.24298df8.png\";"],"sourceRoot":""}