{"version":3,"sources":["userActions/userActions.js","actions/index.js","actions/types.js","Components/Node/Node.js","Algorithms/BreadthFirstSearch.js","Algorithms/Algofunctions/Algofunctions.js","Algorithms/DebthFirstSearch.js","dataStructures/priorityQueue.js","Algorithms/Dijkstra.js","Algorithms/GreedyBestFirstSearch.js","Algorithms/ATreeSearch.js","MazeAlgorithms/setOuterWalls.js","MazeAlgorithms/recursiveDivision.js","MazeAlgorithms/recursiveBacktracing.js","userAlgo/userAlgo.js","functions/ifContainsObject.js","Components/Grid/Grid.js","Components/TutorialModal/ModalSections/ModalSections.js","Components/TutorialModal/ModalSections/ModalSections2.js","Components/TutorialModal/ModalSections/ModalSections3.js","Components/TutorialModal/TutorialModal.js","Components/NavBar/NavBar.js","App.js","reducers/selectActionReducer.js","reducers/selectGridReducer.js","reducers/selectAlgoReducer.js","reducers/selectMazeAlgoReducer.js","reducers/index.js","store.js","index.js","Components/Grid/Grid.module.css","Components/TutorialModal/tutorialImages/startAndEnd.png","Components/TutorialModal/tutorialImages/RunAlgo.png"],"names":["selectStartNode","selectEndNode","selectTraffic","selectWall","selectAction","userAction","dispatch","type","payload","Node","state","iconName","isHovered","clickButton","console","log","props","selectGridData","selectedGrid","row","column","selectedGrids","startingSelected","selectGrid","updateState","endingSelected","distance","prevNode","mouseDownEvent","e","setState","document","getElementById","focus","isWall","isStart","isEnd","isWeight","className","mouseOutEvent","pressDownKey","key","toLowerCase","myStyle","background","this","isPath","id","onClick","onMouseEnter","onMouseLeave","onKeyDown","tabIndex","style","Component","connect","BFS","grid","startRow","startColumn","endRow","endColumn","current","maxRow","length","maxColumn","startingNode","queue","visited","isVisited","push","shift","childrens","getChildren","a","shortestPath","getShortestPath","node","children","endingNode","undefined","getChildrens","DFS","startCol","endCol","maxCol","stack","currentNode","pop","priorityQueue","addQueue","includes","currentIdx","parentIdx","Math","floor","parent","addQueueFValue","fValue","deQueue","firstPriority","lastPriority","sinkDown","leftidx","rightidx","left","right","swap","childNode","deQueueFValue","sinkDownFValue","Dijkstra","prevRow","prevColumn","manhattanDistance","abs","GreedyBestFirstSearch","childRow","childCol","ATreeSearch","heuristic","currentDistance","setOuterWalls","width","height","mazeWalls","b","recursiveDivision","minWidth","maxWidth","minHeight","maxHeight","orientation","fieldWidth","fieldHeight","randomColumnIdx","randomRowIdx","selectedColumn","selectedOpeningRow","selectableColumns","openingRows","random","trueMaxHeight","concat","randRowIdx","randColumnIdx","selectedRow","selectedOpeningColumn","selectableRows","openingColumn","trueMaxWidth","recursiveBacktracking","path","startingBegNode","startingEndNode","currentEndNode","currentBegNode","child","createWalls","minRow","minColumn","array","randIdx","randomizeArray","BreadthFS","DebthFS","GreedyBFS","ifContainsObject","arrayObjects","objectVal","ifContains","Grid","action","traffic","walls","componentWillMount","createInitialGrid","addTraffic","selectedNode","newWalls","filter","wall","addWall","newTraffic","trafficVal","resetGrid","oldWalls","forEach","resetSelectedGrids","animatePath","algoResult","nodes","startingGrid","endingGrid","index","selectedAlgo","setTimeout","reverse","alert","animateMaze","outerWalls","selectedMazeAlgo","mazeAlgorithem","runMaze","then","arr","idx","async","testFunction","round","window","innerWidth","nodeRows","createNode","Infinity","algoButton","mazeAlgoButton","onresize","map","rowidx","Styles","columnidx","ModalSections","ModalSections2","src","startAndEndImg","runAlgo","ModalSections3","TutorialModal","pressClose","classList","remove","pressPrev","displaySection","pressNext","n","sections","getElementsByClassName","display","aria-label","class","NavBar","openTutorial","add","selectUserAction","startAction","innerHTML","selectStartAction","selectEndAction","selectTrafficAction","selectWallAction","selectBFSAlgo","selectAlgorithm","selectDFSAlgo","selectDijkstraAlgo","selectGreedyBFS","selectATreeAlgo","selectRecursiveDiv","selectMazeAlgo","selectRecursiveBackTracking","selectTest","data-target","ref","input","endAction","algorithm","App","initialState","selectActionReducer","selectGridReducer","selectAlgoReducer","selectMazeAlgoReducer","combineReducers","middleware","thunk","store","createStore","reducers","applyMiddleware","ReactDOM","render","module","exports"],"mappings":"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","file":"static/js/main.6a8913db.chunk.js","sourcesContent":["export const selectStartNode = \"fa fa-play node-icon\";\nexport const selectEndNode = \"fa fa-stop node-icon\";\nexport const selectTraffic = \"fa fa-car node-icon\";\nexport const selectWall = \"fa fa-ban node-icon\";\nexport const testAction = \"testing\";","import {\n    SELECT_ACTION,\n    SELECT_START_GRID,\n    SELECT_END_GRID,\n    RESET_SELECTED_GRIDS,\n    SELECT_ALGO,\n    SELECT_MAZE_ALGO,\n    IS_HOVER\n} from './types';\n\nimport { \n    selectStartNode, \n    selectEndNode,\n    selectTraffic\n} from '../userActions/userActions'; //This is related to the user's actions\nimport { bool } from 'prop-types';\n\n//select the type of action that the user wants\nexport const selectAction = (userAction) => dispatch => {\n    //If there is something in the user action, then pass it on\n    if(userAction){\n      dispatch({\n          type: SELECT_ACTION,\n          payload: userAction\n      });  \n    }\n}  \n\n//action used to select starting or end grid\nexport const selectGrid = (selectGridData) => dispatch => {\n    /*  \n\n        {\n            userAction: \n            selectedGrid: //This is either the starting or end grid,\n            isSelected: boolean\n        }\n\n    */\n\n    if(selectGridData.userAction === selectStartNode){\n        dispatch({\n            type: SELECT_START_GRID,\n            payload: selectGridData.selectedGrid\n        });\n    }\n    else if (selectGridData.userAction === selectEndNode){\n        dispatch({\n            type: SELECT_END_GRID,\n            payload: selectGridData.selectedGrid\n        });\n    }\n\n\n}\n\n//action used to reset selected starting and ending grids\nexport const resetSelectedGrids = () => dispatch => {\n    dispatch({\n        type: RESET_SELECTED_GRIDS\n    })\n}\n\n//action used to select Algorithm\nexport const selectAlgorithm = (algorithm) => dispatch => {\n    dispatch({\n        type: SELECT_ALGO,\n        payload: algorithm\n    })\n}\n\n//Action is used to trigger and determine if a current node is being hovered over by the mouse or not being hovered over by the mouse\n//This action does not work and hence should be depleted\nexport const isHoverAction = (boolValue) => dispatch => {\n    dispatch({\n        type: IS_HOVER,\n        payload: boolValue\n    })\n}\n\n\n//action used to select a maze algorithm\nexport const selectMazeAlgo = (algorithm) => dispatch => {\n    dispatch({\n        type: SELECT_MAZE_ALGO,\n        payload: algorithm\n    });\n}","export const SELECT_ACTION = \"SELECT_ACTION\";\nexport const SELECT_START_GRID = \"SELECT_START_GRID\";\nexport const SELECT_END_GRID = \"SELECT_END_GRID\";\nexport const RESET_SELECTED_GRIDS = \"RESET_SELECTED_GRIDS\";\nexport const SELECT_ALGO = \"SELECT_ALGO\";\nexport const SELECT_MAZE_ALGO = \"SELECT_MAZE_ALGO\";\nexport const IS_HOVER = \"IS_HOVER\";","import React, {Component} from 'react';\nimport PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\n\nimport { selectGrid, selectAction } from '../../actions/index';\nimport { selectStartNode, selectEndNode, selectTraffic, testAction, selectWall } from '../../userActions/userActions';\nimport \"./Node.css\";\n\nclass Node extends Component {\n\n    state = {\n        iconName: \"\",\n        isHovered: false\n    }\n\n    clickButton = () => {\n        console.log(this.props);\n\n        let selectGridData = {\n            userAction: this.props.userAction,\n            selectedGrid: {\n                row: this.props.row,\n                column: this.props.column\n            }\n        }\n\n        if(this.props.userAction === selectStartNode){\n            if(this.props.selectedGrids.startingSelected !== true){\n                this.props.selectGrid(selectGridData);\n                this.props.updateState(this.props.row, this.props.column, this.props.userAction);\n                this.props.selectAction(selectEndNode);\n            }\n        }\n        else if(this.props.userAction === selectEndNode){\n            if(this.props.selectedGrids.endingSelected !== true){\n                this.props.selectGrid(selectGridData);\n                this.props.updateState(this.props.row, this.props.column, this.props.userAction);\n                this.props.selectAction(selectStartNode); //switch action to select end node\n            }\n        }\n        /* else if(this.props.userAction === selectTraffic){\n            this.props.updateState(this.props.row, this.props.column, this.props.userAction);\n        } */\n        else if(this.props.userAction === testAction){\n            //alert(\"you clicked on me\");\n            console.log(this.props.distance);\n            console.log(\"Prev Node: \", this.props.prevNode);\n\n        }\n    }\n\n    //check out the event listener on mousemove or onmouseenter\n    mouseDownEvent = (e) => {\n\n        this.setState({isHovered: true}); //Set isHovered to true\n        //Set focus to be on the current element that the user is hovering on top of with their mouse\n        document.getElementById(`nodeParent-${this.props.row}-${this.props.column}`).focus();\n\n        //Set the hovered over node icon to whatever the current action is\n        if(this.props.isWall === false && this.props.isStart === false && this.props.isEnd === false && this.props.isWeight === false){\n            if(document.getElementById(`icon-${this.props.row}-${this.props.column}`).className !== \"node-wall\"){\n                document.getElementById(`icon-${this.props.row}-${this.props.column}`).className = this.props.userAction;\n            }\n            //document.getElementById(`icon-${this.props.row}-${this.props.column}`).className = this.props.userAction;\n        }\n    }\n\n    mouseOutEvent = (e) => {\n        this.setState({isHovered: false});\n\n        //Remove the node icon if you're not hovering over a node icon\n        if(this.props.isWall === false && this.props.isStart === false && this.props.isEnd === false && this.props.isWeight === false){\n            //set another if condition here, if the icon does have a className called node-wall, then don't do anything\n            if(document.getElementById(`icon-${this.props.row}-${this.props.column}`).className !== \"node-wall\"){\n                document.getElementById(`icon-${this.props.row}-${this.props.column}`).className = \"\";\n            }\n            //document.getElementById(`icon-${this.props.row}-${this.props.column}`).className = \"\";\n        }\n\n    }\n\n    pressDownKey = (e) => {\n        //Add traffic/weight for the user\n        if(this.state.isHovered && e.key.toLowerCase() === 'w'){\n            if(this.props.userAction === selectTraffic){\n                this.props.updateState(this.props.row, this.props.column, this.props.userAction);\n            }\n        }\n        //add wall for the user\n        else if(this.state.isHovered && e.key.toLowerCase() === 'e'){\n            if(this.props.userAction === selectWall){\n                this.props.updateState(this.props.row, this.props.column, this.props.userAction);\n                //document.getElementById(`icon-${this.props.row}-${this.props.column}`).className = \"\";\n            }\n        }\n    }\n\n    render(){\n        \n        let myStyle = {\n            background: \"\"\n        };\n\n        let iconName = \"\";\n\n        if(this.props.isPath === true){\n            myStyle.background = \"hsl(171, 100%, 41%)\";\n        }\n        if(this.props.isStart === true){\n            iconName = selectStartNode;\n        }\n        else if(this.props.isEnd === true){\n            iconName = selectEndNode;\n        }\n        else if(this.props.isWeight === true){\n            iconName = selectTraffic;\n        }\n        else if(this.props.isWall === true){\n            iconName = \"node-wall\";\n            //document.getElementById(`node-${this.props.row}-${this.props.column}`).className = \"node node-wall\";\n        }\n        \n        //Consider adding another div component within this one for css styling purposes\n        return (\n            <div \n                id={`nodeParent-${this.props.row}-${this.props.column}`}\n                className=\"node\" \n                onClick={this.clickButton}\n                onMouseEnter={this.mouseDownEvent}\n                onMouseLeave={this.mouseOutEvent}\n                onKeyDown={this.pressDownKey}\n                tabIndex=\"0\"\n                style={myStyle}\n            >\n                <div \n                    id={`node-${this.props.row}-${this.props.column}`}\n                    className=\"node\"\n                >\n                    <i\n                        id={`icon-${this.props.row}-${this.props.column}`}\n                        className={iconName}\n                    ></i>\n                </div>\n            </div>\n        )\n    }\n}\n\nNode.propTypes = {\n    row: PropTypes.number,\n    column: PropTypes.number,\n    startRow: PropTypes.number,\n    startColumn: PropTypes.number,\n    isVisted: PropTypes.bool,\n    isPath: PropTypes.bool,\n    prevNode: PropTypes.object,\n    updateState: PropTypes.func,\n    isStart: PropTypes.bool,\n    isEnd: PropTypes.bool,\n    isWall: PropTypes.bool,\n    distance: PropTypes.number,\n    isWeight: PropTypes.bool,\n    fValue: PropTypes.number\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        userAction: state.userAction.userAction,\n        selectedGrids: state.selectedGrids\n    }\n}\n\nexport default connect(mapStateToProps, {\n    selectGrid: selectGrid,\n    selectAction: selectAction\n})(Node);","import { unwatchFile } from \"fs\";\nimport { cloneWithoutLoc } from \"@babel/types\";\n\n//This is our breadth first search function\nexport function BFS(grid, startRow, startColumn, endRow, endColumn){\n\n    let counter = 0;\n    let maxRow = grid.length;\n    let maxColumn = grid[0].length;\n    let startingNode = grid[startRow][startColumn]; //this will be our starting node\n    let current;\n    let queue = [];\n    let visited = [];\n\n    //array.push -> push an element in front of an array\n    //array.shift -> remove an element in front of an array\n\n    //Set the startingNode isVisited to true\n    startingNode.isVisited = true;\n    visited.push({\n        row: startRow,\n        column: startColumn\n    });\n\n\n    queue.push(startingNode); //We're pushing our starting node into the queue\n\n    while(queue.length){ //While there is something in the queue, do something below\n\n        current = queue.shift(); //remove first node from queue and assign it to the current variable\n\n        let childrens = getChildren(current, maxRow, maxColumn);\n\n        //loop through each children and mark them as visited\n\n        for (var a = 0; a < childrens.length; a++){\n            let row = childrens[a].row;\n            let column = childrens[a].column;\n\n            if(grid[row][column].isVisited){\n                continue; //skip any node that was already visited\n            }\n\n            if(grid[row][column].isWall){\n                continue;\n            }\n\n            grid[row][column].isVisited = true;\n            visited.push({\n                row: row,\n                column: column\n            });\n\n            grid[row][column].prevNode = {\n                row: current.row,\n                column: current.column\n            }\n            \n            if(endRow === childrens[a].row && endColumn === childrens[a].column){\n\n                let shortestPath = getShortestPath(grid, grid[row][column]);\n\n                return {\n                    shortestPath: shortestPath,\n                    visited: visited\n                } //This will break the loop\n            }\n\n            queue.push(grid[row][column]);\n            \n        }\n    }\n}\n\n\n//This function will take in a node, and it will return the rows and columns of it's childrens\nconst getChildren = (node, maxRow, maxColumn) => {\n    //We're going to get the children of this node\n\n    let row = node.row;\n    let column = node.column;\n    let children = []; //Empty array //We're going to push an object into here\n\n    //grid.length gives us the number of rows\n    //grid[0].length gives us the number of columns\n\n    //add left children\n    if(column-1 >= 0){\n        children.push({\n            row: row,\n            column: column-1\n        })\n    }\n    //add right children\n    if(column+1 < maxColumn){\n        children.push({\n            row: row,\n            column: column+1\n        })\n    }\n    //add top children\n    if(row-1 >= 0){\n        children.push({\n            row: row-1,\n            column: column\n        })\n    }\n    //add bottom children\n    if(row+1 <maxRow){\n        children.push({\n            row: row+1,\n            column: column\n        })\n    }\n\n    return children; //We will return an array of children nodes here\n}\n\n//This function will return the shortest path via BFS\nconst getShortestPath = (grid, endingNode) => {\n    let current = grid[endingNode.row][endingNode.column];\n    let shortestPath = [];\n\n    shortestPath.push({\n        row: endingNode.row,\n        column: endingNode.column\n    });\n\n    while(current.prevNode !== undefined){\n\n        current = grid[current.prevNode.row][current.prevNode.column];\n\n        shortestPath.push({\n            row: current.row,\n            column: current.column\n        });\n    }\n\n    return shortestPath;\n}","//Function used to return childrens of a node\nexport function getChildrens(node, maxRow, maxColumn){\n    let row = node.row;\n    let column = node.column;\n    let children = []; //Empty array //We're going to push an object into here\n\n    //grid.length gives us the number of rows\n    //grid[0].length gives us the number of columns\n\n    //add left children\n    if(column-1 >= 0){\n        children.push({\n            row: row,\n            column: column-1\n        })\n    }\n    //add top children\n    if(row-1 >= 0){\n        children.push({\n            row: row-1,\n            column: column\n        })\n    }\n    //add right children\n    if(column+1 < maxColumn){\n        children.push({\n            row: row,\n            column: column+1\n        })\n    }\n    //add bottom children\n    if(row+1 < maxRow){\n        children.push({\n            row: row+1,\n            column: column\n        })\n    }\n\n    return children; //We will return an array of children nodes here\n}\n\n\n//Function used to return the shorted path of an algorithm\nexport const getShortestPath = (grid, endingNode) => {\n    let current = grid[endingNode.row][endingNode.column];\n    let shortestPath = [];\n\n    shortestPath.push({\n        row: endingNode.row,\n        column: endingNode.column\n    });\n\n    while(current.prevNode !== undefined){\n\n        current = grid[current.prevNode.row][current.prevNode.column];\n\n        shortestPath.push({\n            row: current.row,\n            column: current.column\n        });\n    }\n\n    return shortestPath;\n}\n\nexport function getChildrensDijkstra(grid, node) {\n    let row = node.row;\n    let column = node.column;\n    let maxRow = grid.length;\n    let maxCol = grid[0].length;\n    let childrens = [];\n\n    //add left children\n    if(column-1 >= 0){\n        \n    }\n    //add top children\n    if(row-1 >= 0){\n        \n    }\n    //add right children\n    if(column+1 < maxCol){\n        \n    }\n    //add bottom children\n    if(row+1 < maxRow){\n        \n    }\n\n    return childrens; //We will return an array of children nodes here\n}\n\nexport const randomizeArray = (array) => {\n    for (let a = array.length - 1; a > 0; a--){\n        let randIdx = Math.floor(Math.random() * (a + 1)); //get's random index from 0 to length of array\n        [array[a], array[randIdx]] = [array[randIdx], array[a]];\n    }\n}","\n\nimport { getChildrens, getShortestPath, randomizeArray } from './Algofunctions/Algofunctions';\n\n\nexport function DFS(grid, startRow, startCol, endRow, endCol){\n\n    let maxRow = grid.length;\n    let maxCol = grid[0].length;\n    let startingNode = grid[startRow][startCol]; \n    let stack = [];\n    let visited = []; //This will be an array of objects\n    /*\n        {\n            row: rowHere,\n            column: columnHere\n        }\n    */\n\n    /*\n        Data that each node contains    \n\n        row: row,\n        column: column,\n        startRow: undefined,\n        startColumn: undefined,\n        isVisited: false,\n        isPath: false,\n        prevNode: undefined,\n        isStart: false,\n        isEnd: false,\n    */\n\n    startingNode.isVisited = true;\n    visited.push({\n        row: startRow,\n        column: startCol\n    })\n    stack.push(startingNode); //Pushes the starting node into the stack\n\n    //While there is something in our stack, execute the following code below\n    while(stack.length){\n\n        let currentNode = stack.pop(); //Remove last element of your stack and assign it to the currentNode variable\n        if(currentNode.isVisited === false){\n            currentNode.isVisited = true;\n            visited.push({\n                row: currentNode.row,\n                column: currentNode.column\n            });\n        }\n\n        if(endRow === currentNode.row && endCol === currentNode.column){\n\n            //This function does not work with DFS to find the shortest path\n            let shortestPath = getShortestPath(grid, grid[currentNode.row][currentNode.column]);\n\n            return {\n                shortestPath: shortestPath,\n                visited: visited\n            }\n        }\n\n        //Create a function to retrieve childrens\n        let childrens = getChildrens(currentNode, maxRow, maxCol);\n\n        //randomizeArray(childrens);\n\n        for(var a = 0; a < childrens.length; a++){\n            let row = childrens[a].row;\n            let column = childrens[a].column;\n\n            if(grid[row][column].isVisited){\n                continue;\n            }\n            if(grid[row][column].isWall){\n                continue;\n            }\n            \n            stack.push(grid[row][column]);\n\n            grid[row][column].prevNode = {\n                row: currentNode.row,\n                column: currentNode.column\n            }\n\n        }\n    }\n}","class priorityQueue {\n    constructor(){\n        this.queue = [] //We'll push our nodes into this queue\n    }\n\n    addQueue = (node) => {\n        if(!this.queue.includes(node)){\n            //console.log(\"this is true\");\n            //Only add to the queue if the node is not already there\n            this.queue.push(node);\n        }\n        //this.queue.push(node);\n\n        //Bubble the node up based on priority, meaning distance\n        let currentIdx = this.queue.length - 1;\n        let currentNode = this.queue[currentIdx];\n\n        while(currentIdx > 0){\n            //console.log(currentIdx);\n            let parentIdx = Math.floor((currentIdx-1)/2);\n            let parent = this.queue[parentIdx];\n\n            if(currentNode.distance > parent.distance) break;\n            this.queue[parentIdx] = currentNode;\n            this.queue[currentIdx] = parent;\n\n            currentIdx = parentIdx;\n        }\n    }\n\n    //Create an addQueue function for the ATreeSearch algorithm\n    addQueueFValue = (node) => {\n        if(!this.queue.includes(node)){\n            //console.log(\"this is true\");\n            //Only add to the queue if the node is not already there\n            this.queue.push(node);\n        }\n        //this.queue.push(node);\n\n        //Bubble the node up based on priority, meaning distance\n        let currentIdx = this.queue.length - 1;\n        let currentNode = this.queue[currentIdx];\n\n        while(currentIdx > 0){\n            //console.log(currentIdx);\n            let parentIdx = Math.floor((currentIdx-1)/2);\n            let parent = this.queue[parentIdx];\n\n            if(currentNode.fValue > parent.fValue) break;\n            this.queue[parentIdx] = currentNode;\n            this.queue[currentIdx] = parent;\n\n            currentIdx = parentIdx;\n        }\n    }\n\n    deQueue = () => {\n        //console.log(\"deQueue initialized\");\n        let firstPriority = this.queue[0];\n        let lastPriority = this.queue.pop(); //This should be trickled down\n\n        if(this.queue.length > 0){\n            this.queue[0] = lastPriority;\n            this.sinkDown();\n        }\n\n        return firstPriority;\n    }\n\n    sinkDown = () => {\n        let currentIdx = 0;\n        let length = this.queue.length;\n        let currentNode = this.queue[0];\n\n        while(true){\n            //Find the current Node's childs\n            let leftidx = 2 * currentIdx + 1; //check if these are out of bounds\n            let rightidx = 2 * currentIdx + 2;\n            let left, right;\n            let swap = null;\n\n            if(leftidx < length){\n                left = this.queue[leftidx];\n                if(currentNode.distance > left.distance){\n                    swap = leftidx;\n                }\n            }\n            if(rightidx < length){\n                right = this.queue[rightidx];\n                if(\n                    (currentNode.distance > right.distance && swap === null) \n                    || \n                    (swap !== null && right.distance < left.distance )){\n                        swap = rightidx;\n                }\n            }\n\n            if(swap === null) break;\n            let childNode = this.queue[swap];\n            this.queue[currentIdx] = childNode;\n            this.queue[swap] = currentNode;\n            currentIdx = swap;\n\n        }\n    }\n\n    //deQueue for fValue\n    deQueueFValue = () => {\n        //console.log(\"deQueue initialized\");\n        let firstPriority = this.queue[0];\n        let lastPriority = this.queue.pop(); //This should be trickled down\n\n        if(this.queue.length > 0){\n            this.queue[0] = lastPriority;\n            this.sinkDownFValue();\n        }\n\n        return firstPriority;\n    }\n\n    //sinkDown for fValue\n    sinkDownFValue = () => {\n        let currentIdx = 0;\n        let length = this.queue.length;\n        let currentNode = this.queue[0];\n\n        while(true){\n            //Find the current Node's childs\n            let leftidx = 2 * currentIdx + 1; //check if these are out of bounds\n            let rightidx = 2 * currentIdx + 2;\n            let left, right;\n            let swap = null;\n\n            if(leftidx < length){\n                left = this.queue[leftidx];\n                if(currentNode.fValue > left.fValue){\n                    swap = leftidx;\n                }\n            }\n            if(rightidx < length){\n                right = this.queue[rightidx];\n                if(\n                    (currentNode.fValue > right.fValue && swap === null) \n                    || \n                    (swap !== null && right.fValue < left.fValue )){\n                        swap = rightidx;\n                }\n            }\n\n            if(swap === null) break;\n            let childNode = this.queue[swap];\n            this.queue[currentIdx] = childNode;\n            this.queue[swap] = currentNode;\n            currentIdx = swap;\n\n        }\n    }\n\n}\n\nexport default priorityQueue;","import { getChildrens, getShortestPath } from './Algofunctions/Algofunctions';\nimport priorityQueue from '../dataStructures/priorityQueue';\n\nconst Dijkstra = (grid, startRow, startColumn, endRow, endColumn) => {\n\n    let maxRow = grid.length;\n    let maxCol = grid[0].length;\n    let startingNode = grid[startRow][startColumn]; \n    let queue = new priorityQueue();\n    let visited = [];\n    startingNode.distance = 0;\n    queue.addQueue(startingNode);\n    let currentNode;\n    let childrens;\n\n    while(queue.queue.length){\n        currentNode = queue.deQueue(); //Remove first priority from your array\n        if(currentNode.isWall){continue} //re-add this\n\n        childrens = getChildrens(currentNode, maxRow, maxCol);\n        if(currentNode.isVisited === false){\n            currentNode.isVisited = true;\n            visited.push({\n                row: currentNode.row,\n                column: currentNode.column\n            });\n        }\n        \n        for(var a = 0; a < childrens.length; a++){\n\n            //It looks like adding the conditional statement here is resolving the issue\n            if(currentNode.row === endRow && currentNode.column === endColumn){\n                let shortestPath = getShortestPath(grid, grid[endRow][endColumn]);\n                //Error is occuring in this section of the code\n                return {\n                    visited: visited,\n                    shortestPath: shortestPath\n                }\n            }\n\n            //let prevDistance = grid[currentNode.row][currentNode.column].distance;\n            if(grid[childrens[a].row][childrens[a].column].isVisited){continue}\n            //If current child node is a wall, then skip the current node\n            if(grid[childrens[a].row][childrens[a].column].isWall){continue}\n\n\n            \n\n            if(grid[childrens[a].row][childrens[a].column].prevNode === undefined){\n                grid[childrens[a].row][childrens[a].column].prevNode = {\n                    row: currentNode.row,\n                    column: currentNode.column\n                }\n            }\n\n            //Purpose of the code below\n            //This will compare the distance between the current node and this child's prevNode\n            //Which ever is the lowest, will be assigned as the child's previous node\n            if(grid[childrens[a].row][childrens[a].column].prevNode.row !== currentNode.row \n                && grid[childrens[a].row][childrens[a].column].prevNode.column !== currentNode.column\n            ){\n                let prevRow = grid[childrens[a].row][childrens[a].column].prevNode.row;\n                let prevColumn = grid[childrens[a].row][childrens[a].column].prevNode.column;\n                let prevNode = grid[prevRow][prevColumn];\n\n                if(prevNode.distance !== currentNode.distance){\n                    if(prevNode.distance < currentNode.distance){\n                        grid[childrens[a].row][childrens[a].column].prevNode = {\n                            row: prevRow,\n                            column: prevColumn\n                        }\n                    }\n\n                }\n                \n            }\n\n            //Add distance\n            if(grid[childrens[a].row][childrens[a].column].isWeight){\n                grid[childrens[a].row][childrens[a].column].distance = 10 + grid[grid[childrens[a].row][childrens[a].column].prevNode.row][grid[childrens[a].row][childrens[a].column].prevNode.column].distance\n            }\n            else {\n                grid[childrens[a].row][childrens[a].column].distance = 1 + grid[grid[childrens[a].row][childrens[a].column].prevNode.row][grid[childrens[a].row][childrens[a].column].prevNode.column].distance\n            }\n\n            /* if(currentNode.row === endRow && currentNode.column === endColumn){\n                let shortestPath = getShortestPath(grid, grid[endRow][endColumn]);\n                //Error is occuring in this section of the code\n                return {\n                    visited: visited,\n                    shortestPath: shortestPath\n                }\n            } */\n\n            queue.addQueue(grid[childrens[a].row][childrens[a].column]);\n\n        }\n\n    }\n\n}\n\nexport default Dijkstra;\n","import { getChildrens, getShortestPath } from './Algofunctions/Algofunctions';\nimport priorityQueue from '../dataStructures/priorityQueue';\n\n//My priorityQurue data structure should work with this algorithm, we want to visit the node that has a \n//lower estimated distance to the end\n\nconst GreedyBestFirstSearch = (grid, startRow, startColumn, endRow, endColumn) => {\n    let queue = new priorityQueue();\n\n    //For our Greedy BFS, our heuristic (an estimate measure of how far something is to an endpoint) is going to be based on Manhattan Distance\n\n    //Column = X coordinates\n    //Row = Y coordinates\n\n    let maxRow = grid.length; //used on the getChildrens algorithm\n    let maxColumn = grid[0].length; //used on the getChildrens algorithm\n    let startingNode = grid[startRow][startColumn];\n    let currentNode;\n    let visited = [];\n\n    //set starting nodes distance to 0 since we want to remove it from our queue first\n    startingNode.distance = 0;\n    queue.addQueue(startingNode);\n\n    while(queue.queue.length){\n        currentNode = queue.deQueue();\n        if(currentNode.isVisited !== true){\n            currentNode.isVisited = true;\n            visited.push({\n                row: currentNode.row,\n                column: currentNode.column\n            });\n        }\n\n        let childrens = getChildrens(currentNode, maxRow, maxColumn);\n\n        for(var a = 0; a < childrens.length; a++){\n            //loop through each of the current node's children\n            let childRow = childrens[a].row;\n            let childCol = childrens[a].column;\n            let distance = manhattanDistance(childRow, childCol, endRow, endColumn); //This is our hueristic\n\n            if(currentNode.row === endRow && currentNode.column === endColumn){\n                let shortestPath = getShortestPath(grid, grid[endRow][endColumn]);\n                return {\n                    visited: visited,\n                    shortestPath: shortestPath\n                }\n            }\n\n            //Don't do anything with this node if it is a wall or already visited\n            if(grid[childRow][childCol].isWall){continue}\n            if(grid[childRow][childCol].isVisited){continue}\n\n            //assign current child's previous node\n            grid[childRow][childCol].prevNode = {\n                row: currentNode.row,\n                column: currentNode.column\n            };\n\n            //assign the current child's distance\n            if(grid[childRow][childCol].isWeight){\n                grid[childRow][childCol].distance = distance + 14;\n            }\n            else {\n                grid[childRow][childCol].distance = distance \n            }\n\n            //add current child node into the queue after it has been assigned a previous node and distance\n            queue.addQueue(grid[childRow][childCol]);\n\n        }\n    }\n}\n\n//This is our heuristic, this function will calculate the estimate distance between a node and our selected end node\nconst manhattanDistance = (row, column, endRow, endColumn) => {\n    /*\n        (x1, x2)\n        (y1, y2)\n\n        manHattanDistance formula = | x1- y1 | + | x2 - y2 |\n\n    */\n\n    let estDistance = (Math.abs(row - endRow) + Math.abs(column - endColumn));\n\n    return estDistance;\n}\n\nexport default GreedyBestFirstSearch;","import { getChildrens, getShortestPath } from './Algofunctions/Algofunctions';\nimport priorityQueue from '../dataStructures/priorityQueue';\n\nconst ATreeSearch = (grid, startRow, startColumn, endRow, endColumn) => {\n    let maxRow = grid.length;\n    let maxCol = grid[0].length;\n    let startingNode = grid[startRow][startColumn]; \n    let queue = new priorityQueue();\n    let visited = [];\n    startingNode.distance = 0;\n    queue.addQueueFValue(startingNode);\n    let currentNode;\n    let childrens;\n\n    while(queue.queue.length){\n        currentNode = queue.deQueueFValue(); //Remove first priority from your array\n        if(currentNode.isWall){continue}\n\n        childrens = getChildrens(currentNode, maxRow, maxCol);\n        if(currentNode.isVisited === false){\n            currentNode.isVisited = true;\n            visited.push({\n                row: currentNode.row,\n                column: currentNode.column\n            });\n        }\n        \n        //We're looping through each children and assigning their distance and prevNode for them\n        for(var a = 0; a < childrens.length; a++){\n\n            let heuristic = manhattanDistance(childrens[a].row, childrens[a].column, endRow, endColumn);\n            let currentDistance;\n\n            if(currentNode.row === endRow && currentNode.column === endColumn){\n                let shortestPath = getShortestPath(grid, grid[endRow][endColumn]);\n                return {\n                    visited: visited,\n                    shortestPath: shortestPath\n                }\n            }\n\n            //let prevDistance = grid[currentNode.row][currentNode.column].distance;\n            if(grid[childrens[a].row][childrens[a].column].isVisited){continue}\n            //If current child node is a wall, then skip the current node\n            if(grid[childrens[a].row][childrens[a].column].isWall){continue}\n\n            if(grid[childrens[a].row][childrens[a].column].prevNode === undefined){\n                grid[childrens[a].row][childrens[a].column].prevNode = {\n                    row: currentNode.row,\n                    column: currentNode.column\n                }\n            }\n\n            //Purpose of the code below\n            //This will compare the distance between the current node and this child's prevNode\n            //Which ever is the lowest, will be assigned as the child's previous node\n            if(grid[childrens[a].row][childrens[a].column].prevNode.row !== currentNode.row \n                && grid[childrens[a].row][childrens[a].column].prevNode.column !== currentNode.column\n            ){\n                let prevRow = grid[childrens[a].row][childrens[a].column].prevNode.row;\n                let prevColumn = grid[childrens[a].row][childrens[a].column].prevNode.column;\n                let prevNode = grid[prevRow][prevColumn];\n\n                if(prevNode.distance !== currentNode.distance){\n                    if(prevNode.distance < currentNode.distance){\n                        grid[childrens[a].row][childrens[a].column].prevNode = {\n                            row: prevRow,\n                            column: prevColumn\n                        }\n                    }\n\n                }\n                \n            }\n\n            //Add distance\n            if(grid[childrens[a].row][childrens[a].column].isWeight){\n                //We're taking the current child's prevNode's distance and adding it to the current child's distance\n                currentDistance = 10 + grid[grid[childrens[a].row][childrens[a].column].prevNode.row][grid[childrens[a].row][childrens[a].column].prevNode.column].distance;\n                grid[childrens[a].row][childrens[a].column].distance = currentDistance;\n                grid[childrens[a].row][childrens[a].column].fValue = currentDistance + heuristic;\n            }\n            else {\n                currentDistance = 1 + grid[grid[childrens[a].row][childrens[a].column].prevNode.row][grid[childrens[a].row][childrens[a].column].prevNode.column].distance;\n                grid[childrens[a].row][childrens[a].column].distance = currentDistance;\n                grid[childrens[a].row][childrens[a].column].fValue = currentDistance + heuristic;\n            }\n\n            queue.addQueueFValue(grid[childrens[a].row][childrens[a].column]);\n\n        } //For loop\n\n    }\n}\n\n//This is our heuristic, this function will calculate the estimate distance between a node and our selected end node\nconst manhattanDistance = (row, column, endRow, endColumn) => {\n    /*\n        (x1, x2)\n        (y1, y2)\n\n        manHattanDistance formula = | x1- y1 | + | x2 - y2 |\n\n    */\n\n    let estDistance = (Math.abs(row - endRow) + Math.abs(column - endColumn));\n\n    return estDistance;\n}\n\nexport default ATreeSearch;","const setOuterWalls = (grid, width, height) => {\n    //This is going to be our helper function, we will create a recursive function, that will add walls into the array below\n    let mazeWalls = []; //Set this as an empty array for now\n\n    //First of wall, execute a function that will loop through all the outer edges of your current graph and display them as walls\n    //push columns\n    for (var a = 0; a < width; a ++){\n        //This code works\n        mazeWalls.push({\n            row: 0,\n            column: a\n        });\n        mazeWalls.push({\n            row: height-1,\n            column: a\n        });\n    }\n\n    //push rows\n    for (var b = 1; b < height; b++){\n        mazeWalls.push({\n            row: b,\n            column: 0\n        });\n        mazeWalls.push({\n            row: b,\n            column: width-1\n        })\n    }\n\n    return mazeWalls;\n}\n\nexport default setOuterWalls;","\nconst recursiveDivision = (grid, minWidth, maxWidth, minHeight, maxHeight) => {\n    //orientation determines whether we want to divide our graph horizantally or vertically first\n    //width === columns\n    //height === rows\n\n    let mazeWalls = [];\n    let vertical = \"vertical\";\n    let horizantal = \"horizontal\";\n    let orientation;\n    let fieldWidth = (maxWidth - minWidth)+3;\n    let fieldHeight = (maxHeight - minHeight)+3;\n\n    //Assign orientation\n    //if width is greater than height, we disect vertically\n    if(fieldWidth > fieldHeight){\n        orientation = vertical;\n    }\n    else if(fieldWidth < fieldHeight){\n        orientation = horizantal;\n    }\n    else {\n        orientation = horizantal;\n    }\n\n    //base case for recursive function\n    if(fieldWidth <=2 || fieldHeight <=2){\n        return mazeWalls;\n    }\n\n    if(orientation === vertical){\n        let selectableColumns = []; //the list of columns that we can choose and select to be a wall\n        let openingRows = []; //List of rows that we're allowed to select to be an opening\n        let randomColumnIdx;\n        let randomRowIdx;\n        let selectedColumn;\n        let selectedOpeningRow;\n\n        //add list of selectable columns into the array\n        for(let a = minWidth; a <= maxWidth; a+=2){\n            selectableColumns.push(a);\n        }\n\n        //add list of selectable opening rows into the array\n        for(let b = minHeight-1; b <= maxHeight+1; b+=2){\n            openingRows.push(b);\n        }\n\n        randomColumnIdx = Math.floor(Math.random() * selectableColumns.length);\n        randomRowIdx = Math.floor(Math.random() * openingRows.length);\n\n        selectedColumn = selectableColumns[randomColumnIdx];\n        selectedOpeningRow = openingRows[randomRowIdx];\n\n        let trueMinHeight = minHeight - 1; //Subtract by one to get our actual minHeight\n        let trueMaxHeight = maxHeight + 1;\n\n        for(let a = trueMinHeight; a <= trueMaxHeight; a++){\n            if(a === selectedOpeningRow){continue}\n            mazeWalls.push({\n                row: a,\n                column: selectedColumn\n            });\n            //grid[a][selectedColumn].isWall = true;\n            \n        }\n\n        mazeWalls = mazeWalls.concat(recursiveDivision(grid, minWidth, selectedColumn-2, minHeight, maxHeight));\n        mazeWalls = mazeWalls.concat(recursiveDivision(grid, selectedColumn+2, maxWidth, minHeight, maxHeight));\n        \n    }\n    else if(orientation === horizantal){\n        let selectableRows = [];\n        let openingColumn = [];\n        let randRowIdx;\n        let randColumnIdx;\n        let selectedRow;\n        let selectedOpeningColumn;\n\n        for(let a = minHeight; a <=maxHeight; a+=2){\n            selectableRows.push(a);\n        }\n\n        for(let b = minWidth-1; b <= maxWidth+1; b+=2){\n            openingColumn.push(b);\n        }\n\n        randRowIdx = Math.floor(Math.random() * selectableRows.length);\n        randColumnIdx = Math.floor(Math.random() * openingColumn.length);\n\n        selectedRow = selectableRows[randRowIdx];\n        selectedOpeningColumn = openingColumn[randColumnIdx];\n\n        let trueMinWidth = minWidth - 1;\n        let trueMaxWidth = maxWidth + 1;\n\n        for(let a = trueMinWidth; a <= trueMaxWidth; a++){\n            if(a === selectedOpeningColumn){continue}\n            //grid[selectedRow][a].isWall = true;\n            mazeWalls.push({\n                row: selectedRow,\n                column: a\n            });\n        }\n\n        mazeWalls = mazeWalls.concat(recursiveDivision(grid, minWidth, maxWidth, minHeight, selectedRow-2));\n        mazeWalls = mazeWalls.concat(recursiveDivision(grid, minWidth, maxWidth, selectedRow+2, maxHeight));\n        \n    }\n    \n    return mazeWalls;\n\n}\n\nexport default recursiveDivision;","import { randomizeArray } from \"../Algorithms/Algofunctions/Algofunctions\";\n\nconst recursiveBacktracking = (grid, minWidth, maxWidth, minHeight, maxHeight) => {\n    //Find a way to return walls, issue is we can create paths but how would we return the walls?\n    //ideally, function should stop when every node was visited\n    let stack = [];\n    //let visited = []; //We don't need this\n    let path = [];\n    //let pushedNode = {}; //Purpose of this object is to help us identify nodes that have already been pushed into the stack, if node is in stack, do not push it into it\n    let randomRow = Math.floor(Math.random() * (maxHeight - minHeight)) + minHeight; //Will select a random row within range\n    let randomColumn = Math.floor(Math.random() * (maxWidth - minWidth)) + minWidth; //Will select a random column within range\n    let startingBegNode = grid[5][9]; //For now, we're always starting at this node\n    let startingEndNode = grid[5][10]; //starting end node, this will be the first node popped off the stack\n\n    /*\n\n    node props for reference\n\n    row: PropTypes.number,\n    column: PropTypes.number,\n    startRow: PropTypes.number,\n    startColumn: PropTypes.number,\n    isVisted: PropTypes.bool,\n    isPath: PropTypes.bool,\n    prevNode: PropTypes.object,\n    updateState: PropTypes.func,\n    isStart: PropTypes.bool,\n    isEnd: PropTypes.bool,\n    isWall: PropTypes.bool,\n    distance: PropTypes.number,\n    isWeight: PropTypes.bool,\n    fValue: PropTypes.number\n\n    */\n\n    //Set up starting node\n    startingBegNode.isPath = true;\n    startingEndNode.isPath = true;\n    //push beg node first\n    path.push({\n        row: startingBegNode.row,\n        column: startingBegNode.column\n    });\n    //push end node last\n    path.push({\n        row: startingEndNode.row,\n        column: startingEndNode.column\n    })\n\n    //Push two nodes into the stack at once\n    stack.push(startingBegNode);\n    stack.push(startingEndNode);\n\n    //while there is something in the stack\n    while(stack.length){\n\n        //Remove two nodes from the stack at a time\n        let currentEndNode = stack.pop();\n        let currentBegNode = stack.pop(); \n\n        //we might need to change this condition from an and to or, if one of them is already visited then don't continue marking the two nodes as visited\n        if(currentEndNode.isPath === false && currentBegNode.isPath === false){\n            currentEndNode.isPath = true;\n            currentBegNode.isPath = true;\n            path.push({\n                row: currentBegNode.row,\n                column: currentBegNode.column\n            })\n            path.push({\n                row: currentEndNode.row,\n                column: currentEndNode.column\n            })\n        }        \n\n        //return 2d array of childrens, 2-child nodes at a time\n        let childrens = getChildren(currentEndNode, grid, minHeight, maxHeight, minWidth, maxWidth);\n\n        //loop through each children\n        for(let a = 0; a < childrens.length; a++){\n            //within each children is also an array that contains two childrens, they act as a pair\n            for(let b = 0; b < childrens[a].length; b++){\n                //We can afford to do this double loop because there should only be 8 nodes in total, no scaling to worry about\n                let child = childrens[a][b];\n\n                if(grid[child.row][child.column].isPath == true){\n                    continue;\n                }\n                if(grid[child.row][child.column].isWall == true){\n                    continue;\n                }\n\n                //push each children pair into the stack\n                stack.push(grid[child.row][child.column]);\n\n            }\n        }\n\n    }\n\n    //We have the path here\n    //Is there a way to reverse the path and set every other component as that's not a path as a wall?\n    //Create a function here to create/identify walls\n\n    //createWalls(grid);\n    let mazeWalls = createWalls(grid);\n    console.log(mazeWalls);\n    //path\n    return mazeWalls;\n\n}\n\nexport default recursiveBacktracking;\n\n//create a function here called get children\nconst getChildren = (node, grid, minRow, maxRow, minColumn, maxColumn) => {\n    //grid does not need to be passed as a parameter\n    /*\n        bounderies are maxRow and maxColumn\n        were moving by two nodes at a time\n    */\n    let row = node.row;\n    let column = node.column;\n    let childrens = [];\n    let child = [];\n\n\n    //We're checking for two things\n    //If the children nodes are within bounds of the grid\n    //If the children nodes are not hitting a node that's defined as a path\n    \n    if(column-2 > minColumn){\n\n        //We need a condition here to chick if child is already visited\n        //If both the nodes are not visited, then we can add them as nodes. This condition will check if we're within bound of visited nodes\n        \n        if(grid[row][column-1].isPath === false && grid[row][column-2].isPath === false){\n\n            //empty the child array first/used to reset the array\n            child = [];\n            //push the beginning node first\n            child.push({\n                row: row,\n                column: column-1\n            })\n            //Push the end node afterwards\n            child.push({\n                row: row,\n                column: column-2\n            })\n\n            //push child into children\n            childrens.push(child);\n        }\n    }\n\n    //Check right chidlren\n    if(column+2 < maxColumn){\n        \n        if(grid[row][column+1].isPath === false && grid[row][column+2].isPath === false){\n            child = [];\n\n            child.push({\n                row: row,\n                column: column+1\n            })\n            child.push({\n                row: row,\n                column: column+2\n            })\n\n            childrens.push(child);\n        }\n    }\n\n    //Check top chirdren\n    if(row-2 > minRow){\n        \n        if(grid[row-1][column].isPath === false && grid[row-2][column].isPath === false){\n\n            child = [];\n            child.push({\n                row: row-1,\n                column: column\n            })\n            child.push({\n                row: row-2,\n                column: column\n            })\n            childrens.push(child);\n\n        }\n    }\n\n    //Check bottom children\n    if(row+2 < maxRow){\n        \n        if(grid[row+1][column].isPath === false && grid[row+2][column].isPath === false){\n\n            child = [];\n            child.push({\n                row: row+1,\n                column: column\n            })\n            child.push({\n                row: row+2,\n                column: column\n            })\n            childrens.push(child);\n        }\n    }\n\n    //use functiont to reverse array\n    randomizeArray(childrens);\n\n    //Is there a way to re-arrange, this array?\n    return childrens; //We will return a double array that consists of the following:\n    /*\n\n        [\n            [begNode, endNode],\n            [begNode, endNode]\n        ]\n\n    */\n\n}\n\n//Once the paths is identified, the purpose of this function is to create walls based on the given path\n//What's the smartest way to do this?\nconst createWalls = (grid) => {\n    //We can loop through each node in the grid, and if a node is not a path, then make it a wall\n    //If it is a path, then remove it as a path??\n    let mazeWalls = [];\n    \n    //Is this the most efficient way to do this?\n    for(let row = 1; row < grid.length-1; row++){\n        for(let column = 1; column < grid[0].length-1; column++){\n            //if this condition is true, then push the row and column into the mazeWalls array\n            if(grid[row][column].isPath != true){\n                console.log(\"this is a wall\");\n                mazeWalls.push({\n                    row: row,\n                    column: column\n                });\n            }\n            else {\n                //if the node is a path, let's not set it up as a path then\n                grid[row][column].isPath = false;\n\n            }\n        }\n    }\n\n    return mazeWalls;\n    \n}","export const BreadthFS = \"Breadth-First-Search\";\nexport const DebthFS = \"Debth-First-Search\";\nexport const DijkstraAlgo = \"Dijkstra's Algorithm\";\nexport const GreedyBFS = \"Greedy Best-First-Search\";\nexport const ATreeSearchAlgo = \"A* Search Algorithm\";\nexport const RecursiveDivision = \"Recursive Division\";\nexport const RecursiveBacktracking = \"Recursive Backtracking\";","/*\n    Purpose of this function. It will take in an array and object. If the object is already within the array\n    then output it as true and stop the function.\n*/\nconst ifContainsObject = (arrayObjects, objectVal) => {\n    var ifContains = false;\n\n    /*\n\n        object should contain the following\n\n        object = {\n            row: row,\n            column: column\n        }\n\n    */\n\n    for(var a = 0; a < arrayObjects.length; a++){\n        if(arrayObjects[a].row === objectVal.row \n        && arrayObjects[a].column === objectVal.column){\n            ifContains = true;\n        }\n    }\n\n    //return true if array contains the object\n    return ifContains;\n\n}\n\nexport default ifContainsObject;","import React, {Component} from 'react';\nimport { connect } from 'react-redux';\nimport Styles from './Grid.module.css';\nimport Node from \"../Node/Node\";\nimport { BFS } from \"../../Algorithms/BreadthFirstSearch\";\nimport { DFS } from \"../../Algorithms/DebthFirstSearch\";\nimport Dijkstra from \"../../Algorithms/Dijkstra\";\nimport GreedyBestFirstSearch from \"../../Algorithms/GreedyBestFirstSearch\";\nimport ATreeSearch from \"../../Algorithms/ATreeSearch\";\nimport setOuterWalls from \"../../MazeAlgorithms/setOuterWalls\";\nimport recursiveDivision from \"../../MazeAlgorithms/recursiveDivision\";\nimport recursiveBacktracking from \"../../MazeAlgorithms/recursiveBacktracing\";\nimport { selectStartNode, selectEndNode, selectTraffic, selectWall } from '../../userActions/userActions';\nimport { BreadthFS, DebthFS, DijkstraAlgo, GreedyBFS, ATreeSearchAlgo, RecursiveDivision, RecursiveBacktracking } from '../../userAlgo/userAlgo';\nimport { selectAction, resetSelectedGrids } from '../../actions/index';\nimport ifContainsObject from '../../functions/ifContainsObject';\nimport dataStructureTest from '../../dataStructures/dataStructureTest';\nimport { func } from 'prop-types';\nimport { writeFile } from 'fs';\n\nclass NodeTest {\n    constructor(val){\n        this.val = val;\n    }\n}\n\nclass Grid extends Component {\n    \n    state = {\n        grid: [],\n        startRow: null,\n        startColumn: null,\n        endRow: null,\n        endColumn: null,\n        action: undefined,\n        shortestPath: [], //We probably don't need this anymore\n        visited: [],\n        traffic: [],\n        walls: [],\n\n    }\n\n    componentWillMount = () => {\n        let grid = this.createInitialGrid();\n        this.setState({grid})\n    }\n\n    addTraffic = (row, column) => {\n        let traffic = this.state.traffic;\n        let walls = this.state.walls;\n        let selectedNode = {\n            row: row,\n            column: column\n        }\n\n        if(ifContainsObject(traffic, selectedNode) === false){\n            //if the traffic array doesn't contain the your object, add it into the object\n            //For this reason, this won't allow us to add multiple of the same objects\n            traffic.push(selectedNode);\n        }\n\n        if(ifContainsObject(walls, selectedNode) === true){\n            /*\n                New example of how to filter an array\n                \n                let newArray = testArray.filter(function (el) {\n                    return el.row !== object1.row ||\n                    el.column !== object1.column\n                });\n            */\n\n            //The code below will filter out and remove the \n            let newWalls = walls.filter(function (wall){\n                return wall.row !== selectedNode.row ||\n                wall.column !== selectedNode.column\n            });\n            this.setState({walls: newWalls});\n        }\n\n\n    }\n\n    addWall = (row, column) => {\n        let traffic = this.state.traffic;\n        let walls = this.state.walls;\n        let selectedNode = {\n            row: row,\n            column: column\n        }\n\n        if(ifContainsObject(walls, selectedNode) === false){\n            walls.push(selectedNode);\n        }\n        if(ifContainsObject(traffic, selectedNode) === true){\n            let newTraffic = traffic.filter(function (trafficVal){\n                return trafficVal.row !== selectedNode.row ||\n                trafficVal.column !== selectedNode.column\n            });\n            this.setState({traffic: newTraffic});\n        }\n\n    }\n\n    //This function will be used to update the grid\n    updateState = (row, column, userAction) => {\n        let grid = this.state.grid;\n\n        //grid[row][column]\n        if(userAction === selectStartNode){\n            grid[row][column].isStart = true;\n        }\n        else if(userAction === selectEndNode){\n            grid[row][column].isEnd = true;\n        }\n        //If this action is selected, assign the current node as your weight\n        else if(userAction === selectTraffic){\n            grid[row][column].isWall = false;\n            grid[row][column].isWeight = true;\n            this.addTraffic(row, column);\n\n            //Everytime this code gets executed, we want to push it into an array\n        }\n        else if(userAction === selectWall){\n            grid[row][column].isWall = true;\n            grid[row][column].isWeight = false;\n            this.addWall(row, column);\n        }\n\n        this.setState({grid: grid});\n    }\n\n    resetGrid = () => {\n        //console.log(this.state.walls);\n        let oldWalls = this.state.walls;\n        let grid = this.createInitialGrid();\n        this.setState({grid})\n        this.setState({traffic: []})\n        this.setState({walls: []});\n        let nodes = this.state.visited;\n\n        /* for(var a =  0; a < this.state.visited.length; a++){\n            document.getElementById(`node-${nodes[a].row}-${nodes[a].column}`).className = \"node\";\n        } */\n\n        //reset every visited node back to original node\n        this.state.visited.forEach(node => {\n            document.getElementById(`node-${node.row}-${node.column}`).className = \"node\";\n        });\n\n        //reset every node walls back to original node\n        oldWalls.forEach(node => {\n            document.getElementById(`icon-${node.row}-${node.column}`).className = \"node\"; //Set up as original node\n        })\n\n        //Place function to reset the walls here\n        this.props.resetSelectedGrids();\n        this.props.selectAction(selectStartNode);\n        //Create an action to reset the selectGrids state\n    }\n\n    animatePath = () => {\n\n        let grid = this.createInitialGrid(); //This may be inefficient. We don't always want to re-create our grid\n        let nodes = this.state.visited;\n\n        let startRow = this.props.selectedGrids.startingGrid.row;\n        let startColumn = this.props.selectedGrids.startingGrid.column;\n        let endRow = this.props.selectedGrids.endingGrid.row;\n        let endColumn = this.props.selectedGrids.endingGrid.column;\n        let algoResult;\n        let index = 0;\n\n        //The following code below is used for when the user want's to re-run the alogrithm\n        //reset all nodes\n        for(var a =  0; a < this.state.visited.length; a++){\n            document.getElementById(`node-${nodes[a].row}-${nodes[a].column}`).className = \"node\";\n        }\n\n        if(this.props.selectedGrids.startingSelected){\n            grid[startRow][startColumn].isStart = true;\n        }\n\n        if(this.props.selectedGrids.endingSelected){\n            grid[endRow][endColumn].isEnd = true;\n        }\n\n        //If any traffic was already pre-selected, re-select them for animation.\n        if(this.state.traffic.length > 0){\n            for(var a = 0; a < this.state.traffic.length; a++){\n                grid[this.state.traffic[a].row][this.state.traffic[a].column].isWeight = true;\n            }\n        }\n\n        //If any walls was already pre-selected, re-select them for animation.\n        if(this.state.walls.length > 0){\n            for(var b = 0; b < this.state.walls.length; b++){\n                grid[this.state.walls[b].row][this.state.walls[b].column].isWall = true;\n            }\n        }\n\n        this.setState({grid});\n\n        //The following code is used to run our algorithms\n        if(!this.props.selectedGrids.startingSelected || !this.props.selectedGrids.endingSelected){\n            alert(\"No Starting or End Nodes were selected. Please select a start and end node.\")\n        }\n        else {\n\n            //try{\n\n            if(this.props.selectedAlgo.selectedAlgo === BreadthFS){\n                algoResult = BFS(this.state.grid, startRow, startColumn, endRow, endColumn);\n                this.setState({visited: algoResult.visited});\n            }\n            else if(this.props.selectedAlgo.selectedAlgo === DebthFS){\n                algoResult = DFS(this.state.grid, startRow, startColumn, endRow, endColumn);\n                this.setState({visited: algoResult.visited});\n            }\n            else if(this.props.selectedAlgo.selectedAlgo === DijkstraAlgo){\n                algoResult = Dijkstra(this.state.grid, startRow, startColumn, endRow, endColumn);\n                this.setState({visited: algoResult.visited});\n            }\n            else if(this.props.selectedAlgo.selectedAlgo === GreedyBFS){\n                algoResult = GreedyBestFirstSearch(this.state.grid, startRow, startColumn, endRow, endColumn);\n                this.setState({visited: algoResult.visited});\n            }\n            else if(this.props.selectedAlgo.selectedAlgo === ATreeSearchAlgo){\n                algoResult = ATreeSearch(this.state.grid, startRow, startColumn, endRow, endColumn);\n                this.setState({visited: algoResult.visited});\n            }\n\n            algoResult.visited.forEach(node => {\n                index +=1;\n\n                setTimeout(() => {\n\n                    document.getElementById(`node-${node.row}-${node.column}`).className = \"node node-visited\";\n\n                }, index * 7);\n            });\n\n            algoResult.shortestPath.reverse(); //to reverse the shortestPath\n\n            algoResult.shortestPath.forEach(node => {\n                index+=1;\n                setTimeout(() => {\n                    document.getElementById(`node-${node.row}-${node.column}`).className = \"node node-path\";\n                }, index * 8); //10.5\n            })\n\n            //}//try\n            //catch{\n                //alert(\"Please reset the grid\");\n            //}\n\n\n        }\n    }\n\n    animateMaze = () => {\n        let maxWidth = this.state.grid[0].length;\n        let maxHeight = this.state.grid.length;\n        //let gridCopy = this.state.grid;\n        let outerWalls = setOuterWalls(this.state.grid, maxWidth, maxHeight);\n        let mazeWalls;\n        let index = 0; //used for animation\n\n        if(this.props.selectedMazeAlgo.mazeAlgorithem === RecursiveDivision){\n            //Assign our walls based on the recursive division algorithm\n            mazeWalls = recursiveDivision(this.state.grid, 2, maxWidth-3, 2, maxHeight-3); //We want to start at our max width and max height at -3 in order for the function to work\n        }\n        //Else if algo === recursiveBacktracking, then run the algorithm below\n        else if(this.props.selectedMazeAlgo.mazeAlgorithem === RecursiveBacktracking){\n            mazeWalls = recursiveBacktracking(this.state.grid, 0, maxWidth-1, 0, maxHeight-1);\n        }\n\n        outerWalls = outerWalls.concat(mazeWalls);\n\n        this.runMaze(outerWalls, index, this.state.grid).then(\n           this.setState({walls: outerWalls})\n        );\n        \n    }\n\n    runMaze = async (arr, idx) => {\n        arr.forEach(node => {\n            idx+=1;\n            setTimeout(() => {\n                document.getElementById(`icon-${node.row}-${node.column}`).className = \"node-wall\";\n                this.state.grid[node.row][node.column].isWall = true;\n            }, idx * 5);\n        })\n    }\n\n    testFunction = () => {\n\n        let maxWidth = this.state.grid[0].length;\n        let maxHeight = this.state.grid.length;\n        let index = 0;\n        let path = recursiveBacktracking(this.state.grid, 0, maxWidth-1, 0, maxHeight-1); //-1\n\n        path.forEach(node => {\n            index +=1;\n\n            setTimeout(() => {\n\n                document.getElementById(`node-${node.row}-${node.column}`).className = \"node node-visited\";\n\n            }, index * 7);\n        });\n\n    }\n\n    render(){\n\n        window.onresize = () => {\n            let grid = this.createInitialGrid();\n            this.setState({grid});\n        } \n\n        let algoButton;\n        let mazeAlgoButton;\n\n        if(this.props.selectedAlgo.selectedAlgo){\n            algoButton = <button className=\"button\" type=\"button\" onClick={this.animatePath}>Run {this.props.selectedAlgo.selectedAlgo}</button>\n        }\n        if(this.props.selectedMazeAlgo.mazeAlgorithem){\n            mazeAlgoButton = <button className=\"button\" type=\"button\" onClick={this.animateMaze}>Run {this.props.selectedMazeAlgo.mazeAlgorithem}</button>\n        }\n\n\n        return (\n            <div className=\"grid\">\n                {algoButton}\n                {mazeAlgoButton}\n                <button className=\"button\" type=\"button\" onClick={this.resetGrid}>Reset Grid</button>\n                <button className=\"button\" type=\"button\" onClick={this.testFunction}>Test Button</button>\n                {\n                    this.state.grid.map((nodeRows, rowidx) => {\n                        return (\n                            <div key={rowidx} className={Styles.nodeRows}>\n                                {\n                                    nodeRows.map((node, columnidx) => {\n                                        return <Node \n                                            key={columnidx}\n                                            row={node.row}\n                                            column={node.column}\n                                            startRow={node.startRow}\n                                            startColumn={node.startColumn}\n                                            isVisited={node.isVisited}\n                                            isPath={node.isPath}\n                                            prevNode={node.prevNode}\n                                            updateState={this.updateState}\n                                            isStart={node.isStart}\n                                            isEnd={node.isEnd}\n                                            isWall={node.isWall}\n                                            distance={node.distance}\n                                            isWeight={node.isWeight}\n                                            fValue={node.fValue}\n                                        />\n                                    })\n\n                                }\n                            </div>\n                        )\n                    })\n                }\n            </div>\n        )\n    }\n\n    //Create nodes and push them into our grid above\n    createInitialGrid = () => {\n\n        let grid = [];\n        let currentNode;\n        let width = Math.round(window.innerWidth / 25);\n        let height = 30;\n        \n        //We're going to create our grid here, and push in our node\n\n        for(var a = 0; a < height; a++){ //height\n            let nodeRows = [];\n            for(var b = 0; b < width; b++){ //width\n                //create nodes here\n                currentNode = this.createNode(a, b);\n                nodeRows.push(currentNode);\n            }\n            grid.push(nodeRows);\n        }\n\n        return grid;\n        \n    }\n\n    //Create a node\n    createNode = (row, column) => {\n        //Return the following object\n        return {\n            row: row,\n            column: column,\n            startRow: undefined,\n            startColumn: undefined,\n            isVisited: false,\n            isPath: false,\n            prevNode: undefined,\n            isStart: false,\n            isEnd: false,\n            isWall: false,\n            distance: Infinity,\n            isWeight: false,\n            fValue: Infinity //Value is used for the ATreeSearch algorithm, which relies on distance from starting node + est distance from ending node\n        }\n    }\n\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        selectedGrids: state.selectedGrids,\n        selectedAlgo: state.selectedAlgo,\n        selectedMazeAlgo: state.selectedMazeAlgo\n    }\n}\n\nexport default connect(mapStateToProps, {\n    resetSelectedGrids: resetSelectedGrids,\n    selectAction: selectAction\n})(Grid);","import React, { Component } from 'react';\nimport './ModalSections.css';\n\nclass ModalSections extends Component {\n    render(){\n        return (\n            <div className=\"sections\">\n                <div className=\"content\">\n                    <h3>Overview</h3>\n                    {/*<h2>Title</h2>*/}\n                    <p>Hi, welcome to my pathfinding visualization app that was heavily inspired by Clément Mihailescu. With this website, you have three main tabs to use below.</p>\n                    {/* Place image here */}\n                    <ul>\n                        <li>Action</li>\n                        <ul>\n                            <li>Your list of available actions to choose from. i.e. Start action is used to select a starting node.</li>\n                        </ul>\n                        <li>Algorithms</li>\n                        <ul>\n                            <li>Contains the list of available pathfinding algorithms to choose.</li>\n                        </ul>\n                        <li>Maze Algorithms</li>\n                        <ul>\n                            <li>Contains the list of available maze generation algorithms to choose.</li>\n                        </ul>\n                    </ul>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default ModalSections;","import React, { Component } from 'react';\nimport startAndEndImg from '../tutorialImages/startAndEnd.png'; //imported image\nimport runAlgo from '../tutorialImages/RunAlgo.png';\n\nclass ModalSections2 extends Component {\n    render(){\n        return (\n            <div className=\"sections hide-section\">\n                <div className=\"content\">\n                    <h3>Getting started</h3>\n                    <p> First, select and click on any square in the grid to be your starting node.\n                        Now, after selecting a starting square, your action will automatically switch to the stop action. \n                    </p>\n\n                    <p>\n                        Finally, select any square to be your end destination. You will then see a stop icon displayed on your selected square.\n                        See example of the end result below.\n                    </p>\n                    {/* Place tutorial image here */}\n                    {/* how to import an image\n                    <img \n                        className={styles.projectImage}\n                        src={state.image}\n                    />\n                    */}\n                    <img\n                        className=\"tutorialImage\"\n                        src={startAndEndImg}\n                    />\n                    <p>Finally, click on the \"Run (Algorithm Name Here)\" button to see an animation of your selected alrogrithm.</p>\n                    <img \n                        className=\"tutorialImage\"\n                        src={runAlgo}\n                    />\n\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default ModalSections2;","import React, { Component } from 'react';\n\nclass ModalSections3 extends Component {\n    render(){\n        return (\n            <div className=\"sections hide-section\">\n                <div className=\"content\">\n\n                    <h3>Selecting Walls and Wieghted Nodes (traffic)</h3>\n                    <p>Selecting walls will stop an algorithm from using nodes as a path and can encourage alternative routes. Follow the steps below to select walls.</p>\n                    <ul>\n                        <li>Select the Wall action.</li>\n                        <li>Then, hover over to any nodes and press/hold down the 'e' key. While hovering, nodes will be selected as walls.</li>\n                    </ul>\n\n                    <p>Selecting weighted nodes (traffic), will encourage weighted algorithms to avoid those nodes.\n                    Unlike walls, alrogithms can still use traffic nodes as a path but only if it leads to the shortest possible path.\n                    </p>\n                    <ul>\n                        <li>Select the Traffic action.</li>\n                        <li>Then, hover over to any nodes and press/hold down the 'w' key. While hovering, nodes will be selected as traffic nodes.</li>\n                    </ul>\n\n                </div>\n\n            </div>\n        )\n    }\n}\n\nexport default ModalSections3;","import React, { Component } from 'react';\nimport './TutorialModal.css';\nimport ModalSections from './ModalSections/ModalSections';\nimport ModalSections2 from './ModalSections/ModalSections2'; //page 2\nimport ModalSections3 from './ModalSections/ModalSections3'; //page 3\n\nclass TutorialModal extends Component {\n\n    state = {\n        index: 0\n    }\n\n    pressClose = () => {\n\n        let tutModal = document.getElementById(\"tutModal\");\n        tutModal.classList.remove('is-active'); //This works\n        \n    }\n\n    pressPrev = () => {\n        let idx = this.state.index;\n        this.setState({index: idx +=-1})\n        this.displaySection(this.state.index += -1);\n    }\n\n    pressNext = () => {\n        let idx = this.state.index;\n        this.setState({index: idx += 1})\n        this.displaySection(this.state.index += 1);\n    }\n\n    displaySection = (n) => {\n        let sections = document.getElementsByClassName(\"sections\");\n        let idx = this.state.index;\n        \n        if(n < 0){\n            this.setState({index: sections.length-1});\n            this.state.index = sections.length-1;\n        }\n\n        if(n > sections.length-1){\n            this.setState({index: 0});\n            this.state.index = 0;\n        }\n\n        for (var a = 0; a < sections.length; a++){\n            sections[a].style.display = \"none\";\n        }\n\n        sections[this.state.index].style.display = \"block\";\n    }\n\n    render(){\n        return (\n            <div className=\"tutorialModal\">\n                <div className=\"modal\" id=\"tutModal\"> {/* create a function to deactivate this modal */}\n                    <div className=\"modal-background\"></div>\n                    <div className=\"modal-card\">\n                        <header className=\"modal-card-head\">\n                            <p className=\"modal-card-title\">Tutorial</p>\n                            <button className=\"delete\" aria-label=\"close\" onClick={this.pressClose}></button>\n                        </header>\n\n                        <section className=\"modal-card-body\">\n                            {/* Page 1 of modal */}\n                            <ModalSections />\n                            {/* Page 2 of modal */}\n                            <ModalSections2 />\n                            {/* Page 3 of modal */}\n                            <ModalSections3 />\n                        </section>\n\n                        <footer className=\"modal-card-foot mCardStyler\">\n                            <div className=\"counterElement\">\n                                {this.state.index+1}/3\n                            </div>\n                            <div className=\"\">\n                                {/* <button className=\"button is-success\">Save changes</button>\n                                <button className=\"button\">Cancel</button> */}\n                                <button class=\"button\" onClick={this.pressPrev}>Prev</button>\n                                <button class=\"button\" onClick={this.pressNext}>Next</button>\n                            </div>\n                        </footer>\n                    </div>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default TutorialModal;","import React, { Component } from 'react';\nimport { connect } from 'react-redux';\n\nimport \"./NavBar.css\";\nimport { selectEndNode, selectTraffic, selectWall,  testAction } from '../../userActions/userActions';\nimport { selectAction, selectAlgorithm, selectMazeAlgo } from '../../actions/index';\nimport { BreadthFS, DebthFS, DijkstraAlgo, GreedyBFS, ATreeSearchAlgo, RecursiveDivision, RecursiveBacktracking } from '../../userAlgo/userAlgo';\nimport TutorialModal from \"../TutorialModal/TutorialModal\";\n\nclass NavBar extends Component {\n\n    constructor(props) {\n        super(props);\n    }\n\n    openTutorial = () => {\n        let tutModal = document.getElementById(\"tutModal\");\n\n        tutModal.classList.add(\"is-active\");\n\n    }\n\n    selectUserAction = () => {\n\n        console.log(this.startAction.innerHTML);\n\n        let node = this.startAction;\n\n    }\n\n    selectStartAction = () => {\n        this.props.selectAction(\"fa fa-play node-icon\"); //replace this with the selectStartNode user action\n    }\n\n    selectEndAction = () => {\n        this.props.selectAction(selectEndNode);\n    }\n\n    selectTrafficAction = () => {\n        this.props.selectAction(selectTraffic);\n    }\n\n    selectWallAction = () =>{\n        this.props.selectAction(selectWall);\n    }\n\n    selectBFSAlgo = () => {\n        this.props.selectAlgorithm(BreadthFS);\n    }\n\n    selectDFSAlgo = () => {\n        this.props.selectAlgorithm(DebthFS);\n    }\n\n    selectDijkstraAlgo = () => {\n        this.props.selectAlgorithm(DijkstraAlgo);\n    }\n\n    selectGreedyBFS = () => {\n        this.props.selectAlgorithm(GreedyBFS);\n    }\n\n    selectATreeAlgo = () => {\n        this.props.selectAlgorithm(ATreeSearchAlgo);\n    }\n\n    selectRecursiveDiv = () => {\n        this.props.selectMazeAlgo(RecursiveDivision);\n    }\n\n    selectRecursiveBackTracking = () => {\n        this.props.selectMazeAlgo(RecursiveBacktracking);\n    }\n\n    selectTest = () => {\n        this.props.selectAction(testAction);\n    }\n\n    render(){\n        \n        return (\n            //I think the TutorialModal is defaulted to be hidden\n            <div className=\"NavBar\">\n                {/*<TutorialModal />*/}\n                <TutorialModal />\n\n                <nav className=\"navbar is-transparent\">\n                    <div className=\"navbar-brand\">\n                        {/*\n                        <a className=\"navbar-item\" href=\"https://bulma.io\">\n                            <img src=\"https://bulma.io/images/bulma-logo.png\" alt=\"Bulma: a modern CSS framework based on Flexbox\" width=\"112\" height=\"28\" />\n                        </a>\n                        */}\n                        <div className=\"navbar-burger burger\" data-target=\"navbarExampleTransparentExample\">\n                            <span></span>\n                            <span></span>\n                            <span></span>\n                        </div>\n                    </div>\n\n                    <div id=\"navbarExampleTransparentExample\" className=\"navbar-menu\">\n                        <div className=\"navbar-start\">\n                            {/* <a className=\"navbar-item\" href=\"https://bulma.io/\">\n                                Home\n                            </a> */}\n                            <div className=\"navbar-item has-dropdown is-hoverable\">\n\n                                <a className=\"navbar-link\" >\n\n                                    Action\n                                </a>\n                                <div className=\"navbar-dropdown is-boxed\">\n                                    <div ref={(input) => {\n                                        this.startAction = input\n                                        }} \n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectStartAction}\n                                    >\n                                        <i className=\"fa fa-play node-icon-nav\"></i>\n                                        Start\n                                    </div>\n\n                                    <div ref={(input) => {\n                                        this.endAction = input\n                                        }} \n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectEndAction}\n\n                                    >\n                                        <i className=\"fa fa-stop node-icon-nav\"></i>\n                                        End\n                                    </div>\n\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectTrafficAction}\n                                    >\n                                        <i className=\"fa fa-car node-icon-nav\"></i>\n                                        Traffic\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectWallAction}\n                                    >\n                                        <i className=\"fa fa-ban node-icon-nav\"></i>\n                                        Wall\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectTest}\n                                    >\n                                        <i className=\"fa fa-car node-icon-nav\"></i>\n                                        Test Action\n                                    </div>\n                                </div>\n                            </div>\n                            <div className=\"navbar-item has-dropdown is-hoverable\">\n                                <a className=\"navbar-link\" >\n                                    Algorithms\n                                </a>\n                                <div className=\"navbar-dropdown is-boxed\">\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectBFSAlgo}\n                                    >\n                                        Breadth-First-Search\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectDFSAlgo}\n                                    >\n                                        Debth-First-Search\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectDijkstraAlgo}\n                                    >\n                                        Dijkstra's Algorithm\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectGreedyBFS}\n                                    >\n                                        Greedy Best-First-Search\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectATreeAlgo}\n                                    >\n                                        A* Algorithm\n                                    </div>\n                                </div>\n                            </div>\n\n                            <div className=\"navbar-item has-dropdown is-hoverable\">\n                                <a className=\"navbar-link\" >\n                                    Maze Algorithms\n                                </a>\n                                <div className=\"navbar-dropdown is-boxed\">\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectRecursiveDiv}\n                                    >\n                                        Recursive Division\n                                    </div>\n                                    <div\n                                        className=\"navbar-item navItem-hover\" \n                                        onClick={this.selectRecursiveBackTracking}\n                                    >\n                                        Recursive Backtracking\n                                    </div>\n                                </div>\n                            </div>\n\n                        </div>\n\n                        <div className=\"navbar-end\">\n                            <div className=\"navbar-item\">\n                                <div className=\"buttons\">\n                                    <a className=\"button is-primary\" onClick={this.openTutorial}>\n                                        <strong>Tutorial</strong>\n                                    </a>\n                                </div>\n                            </div>\n                        </div>\n\n                    </div>\n                </nav>\n\n            </div>\n        )\n    }\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        userAction: state.userAction.userAction\n    }\n}\n\nexport default connect(mapStateToProps, {\n    selectAction: selectAction,\n    selectAlgorithm: selectAlgorithm,\n    selectMazeAlgo: selectMazeAlgo\n})(NavBar);","import React from 'react';\n\nimport Grid from './Components/Grid/Grid';\nimport NavBar from './Components/NavBar/NavBar';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <NavBar />\n      <Grid />\n    </div>\n  );\n}\n\nexport default App;","import { SELECT_ACTION } from '../actions/types';\n\nconst initialState = {\n    userAction: \"fa fa-play node-icon\" //For now, this will be our default action\n}\n\nconst selectActionReducer = (state = initialState, action) => {\n    if(action.type === SELECT_ACTION){\n        return {\n            ...state,\n            userAction: action.payload\n        }\n    }\n    else {\n        return {\n            ...state\n        }\n    }\n}\n\nexport default selectActionReducer;\n\n","import { SELECT_START_GRID, SELECT_END_GRID, RESET_SELECTED_GRIDS } from '../actions/types';\nimport { identifier } from '@babel/types';\n\nlet initialState = {\n    startingGrid: {},\n    endingGrid: {},\n    startingSelected: false,\n    endingSelected: false\n}\n\nconst selectGridReducer = (state=initialState, action) => {\n    if(action.type === SELECT_START_GRID){\n        return {\n            ...state,\n            startingGrid: action.payload,\n            startingSelected: true\n        }\n    }\n    else if (action.type === SELECT_END_GRID){\n        return {\n            ...state,\n            endingGrid: action.payload,\n            endingSelected: true\n        }\n    }\n    else if (action.type === RESET_SELECTED_GRIDS){\n        return {\n            ...state,\n            startingGrid: {},\n            endingGrid: {},\n            startingSelected: false,\n            endingSelected: false\n        }\n    }\n    else {\n        return {\n            ...state\n        }\n    }\n}\n\nexport default selectGridReducer;","import { SELECT_ALGO } from '../actions/types';\nimport { BreadthFS } from '../userAlgo/userAlgo';\n\nlet initialState = {\n    selectedAlgo: BreadthFS\n}\n\nconst selectAlgoReducer = (state=initialState, action) => {\n    if(action.type === SELECT_ALGO){\n        return {\n            ...state,\n            selectedAlgo: action.payload\n        }\n    }\n    else {\n        return {\n            ...state\n        }\n    }\n}\n\nexport default selectAlgoReducer;","import { SELECT_MAZE_ALGO } from \"../actions/types\";\nimport { RecursiveDivision } from \"../userAlgo/userAlgo\";\n\nlet initialState = {\n    mazeAlgorithem: RecursiveDivision //Defaults to recursive division algorithm\n}\n\n//action.type\n//action.payload\n\nconst selectMazeAlgoReducer = (state=initialState, action) => {\n    if(action.type === SELECT_MAZE_ALGO){\n        return {\n            ...state,\n            mazeAlgorithem: action.payload\n        }\n    } else {\n        return {\n            ...state\n        }\n    }\n}\n\nexport default selectMazeAlgoReducer;","import { combineReducers } from 'redux';\nimport selectActionReducer from './selectActionReducer';\nimport selectGridReducer from './selectGridReducer';\nimport selectAlgoReducer from './selectAlgoReducer';\nimport selectMazeAlgoReducer from './selectMazeAlgoReducer';\n\nexport default combineReducers({\n    userAction: selectActionReducer,\n    selectedGrids: selectGridReducer,\n    selectedAlgo: selectAlgoReducer,\n    selectedMazeAlgo: selectMazeAlgoReducer\n});","import { createStore, applyMiddleware, compose } from 'redux';\nimport thunk from 'redux-thunk';\n\n//import reducers here\nimport reducers from './reducers'; // <-- this will automatically pick our index.js file\n\nconst initialState = {};\nconst middleware = [thunk];\n\nexport const store = createStore(\n    reducers,\n    initialState,\n    applyMiddleware(...middleware)\n\n    /*\n    compose(\n        applyMiddleware(...middleware),\n        window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\n    )\n    */\n);\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport 'font-awesome/css/font-awesome.min.css';\n\nimport App from './App';\nimport { store } from './store';\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>, \n    document.getElementById('root')\n);\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"nodeRows\":\"Grid_nodeRows__2V7w-\"};","module.exports = \"data:image/png;base64,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\"","module.exports = __webpack_public_path__ + \"static/media/RunAlgo.24298df8.png\";"],"sourceRoot":""}